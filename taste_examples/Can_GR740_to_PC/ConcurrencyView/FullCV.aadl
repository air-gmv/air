---------------------------------------------------
-- AADL2.2
-- TASTE type concurrencyview
-- 
-- generated code: do not edit
---------------------------------------------------

PROPERTY SET AI IS
  Root_System : AADLSTRING
    APPLIES TO(SYSTEM IMPLEMENTATION);
  Disabled_Processing_Tools : LIST OF AADLSTRING
    APPLIES TO(SYSTEM IMPLEMENTATION);
END AI;


PACKAGE concurrencyview::CV
PUBLIC
WITH AI;
WITH DataView;
WITH ocarina_processors_leon;
WITH deploymentview::DV::Node1;

PROCESSOR Node1_gr740_rtems51_posix_cv
EXTENDS ocarina_processors_leon::gr740
END Node1_gr740_rtems51_posix_cv;

PROCESSOR IMPLEMENTATION Node1_gr740_rtems51_posix_cv.final
EXTENDS ocarina_processors_leon::gr740.rtems51_posix
END Node1_gr740_rtems51_posix_cv.final;

PROCESS gr740_partition
EXTENDS deploymentview::DV::Node1::gr740_partition
END gr740_partition;

PROCESS IMPLEMENTATION gr740_partition.final
SUBCOMPONENTS
  vt_gr740_candriver_update : THREAD vt_gr740_candriver_update_vt_gr740_candriver_update.others;
  vt_gr740_candriver_commands : THREAD vt_gr740_candriver_commands_vt_gr740_candriver_commands.others;
  vt_candriver_test_samples : THREAD vt_candriver_test_samples_vt_candriver_test_samples.others;
  gr740_candriver_pi_update : SUBPROGRAM gr740_candriver_pi_update.final;
  gr740_candriver_pi_commands : SUBPROGRAM gr740_candriver_pi_commands.final;
  candriver_test_pi_samples : SUBPROGRAM candriver_test_pi_samples.final;
CONNECTIONS
  PORT vt_candriver_test_samples.OUTPORT_commands_vt -> vt_gr740_candriver_commands.INPORT_artificial_commands;
  PORT vt_gr740_candriver_update.OUTPORT_samples_vt -> vt_candriver_test_samples.INPORT_artificial_samples;
  PORT vt_gr740_candriver_commands.OUTPORT_samples_vt -> vt_candriver_test_samples.INPORT_artificial_samples;
END gr740_partition.final;

SYSTEM deploymentview
END deploymentview;

SYSTEM IMPLEMENTATION deploymentview.final
SUBCOMPONENTS
  gr740_partition : PROCESS gr740_partition.final;
  Node1_gr740_rtems51_posix_cv : PROCESSOR Node1_gr740_rtems51_posix_cv.final;
PROPERTIES
  AI::ROOT_SYSTEM => "generated";
  ACTUAL_PROCESSOR_BINDING => (REFERENCE(Node1_gr740_rtems51_posix_cv)) APPLIES TO gr740_partition;
END deploymentview.final;

THREAD vt_gr740_candriver_update_vt_gr740_candriver_update
FEATURES
  OUTPORT_samples_vt : OUT EVENT PORT ;
END vt_gr740_candriver_update_vt_gr740_candriver_update;

THREAD IMPLEMENTATION vt_gr740_candriver_update_vt_gr740_candriver_update.others
CALLS
  MyCalls : { 
    MyCall : SUBPROGRAM gr740_candriver_pi_update;
  };
PROPERTIES
  DISPATCH_PROTOCOL => Periodic;
  PERIOD => 1000ms;
  DEADLINE => 0ms;
  COMPUTE_EXECUTION_TIME => 0ms..0ms;
END vt_gr740_candriver_update_vt_gr740_candriver_update.others;

THREAD vt_gr740_candriver_commands_vt_gr740_candriver_commands
FEATURES
  INPORT_artificial_commands : IN EVENT PORT  {
    QUEUE_SIZE => 1;
  };
  OUTPORT_samples_vt : OUT EVENT PORT ;
END vt_gr740_candriver_commands_vt_gr740_candriver_commands;

THREAD IMPLEMENTATION vt_gr740_candriver_commands_vt_gr740_candriver_commands.others
CALLS
  MyCalls : { 
    MyCall : SUBPROGRAM gr740_candriver_pi_commands;
  };
PROPERTIES
  DISPATCH_PROTOCOL => Sporadic;
  PERIOD => 0ms;
  DEADLINE => 0ms;
  COMPUTE_EXECUTION_TIME => 0ms..0ms;
END vt_gr740_candriver_commands_vt_gr740_candriver_commands.others;

THREAD vt_candriver_test_samples_vt_candriver_test_samples
FEATURES
  INPORT_artificial_samples : IN EVENT PORT  {
    QUEUE_SIZE => 1;
  };
  OUTPORT_commands_vt : OUT EVENT PORT ;
END vt_candriver_test_samples_vt_candriver_test_samples;

THREAD IMPLEMENTATION vt_candriver_test_samples_vt_candriver_test_samples.others
CALLS
  MyCalls : { 
    MyCall : SUBPROGRAM candriver_test_pi_samples;
  };
PROPERTIES
  DISPATCH_PROTOCOL => Sporadic;
  PERIOD => 0ms;
  DEADLINE => 0ms;
  COMPUTE_EXECUTION_TIME => 0ms..0ms;
END vt_candriver_test_samples_vt_candriver_test_samples.others;

SUBPROGRAM gr740_candriver_pi_update
PROPERTIES
  COMPUTE_EXECUTION_TIME => 0ms..0ms;
  SOURCE_LANGUAGE => (C);
  SOURCE_NAME => "gr740_candriver_pi_update";
  SOURCE_TEXT => ("gr740_candriver/gr740_candriver.c");
END gr740_candriver_pi_update;

SUBPROGRAM IMPLEMENTATION gr740_candriver_pi_update.final
END gr740_candriver_pi_update.final;

SUBPROGRAM gr740_candriver_pi_commands
PROPERTIES
  COMPUTE_EXECUTION_TIME => 0ms..0ms;
  SOURCE_LANGUAGE => (C);
  SOURCE_NAME => "gr740_candriver_pi_commands";
  SOURCE_TEXT => ("gr740_candriver/gr740_candriver.c");
END gr740_candriver_pi_commands;

SUBPROGRAM IMPLEMENTATION gr740_candriver_pi_commands.final
END gr740_candriver_pi_commands.final;

SUBPROGRAM candriver_test_pi_samples
PROPERTIES
  COMPUTE_EXECUTION_TIME => 0ms..0ms;
  SOURCE_LANGUAGE => (C);
  SOURCE_NAME => "candriver_test_pi_samples";
  SOURCE_TEXT => ("candriver_test/candriver_test.c");
END candriver_test_pi_samples;

SUBPROGRAM IMPLEMENTATION candriver_test_pi_samples.final
END candriver_test_pi_samples.final;

END concurrencyview::CV;




---------------------------------------------------
-- AADL2.1
-- TASTE type interfaceview
-- 
-- generated code: do not edit
---------------------------------------------------

PACKAGE interfaceview::FV::gr740_candriver
PUBLIC

WITH Taste;
WITH DataView;
WITH TASTE_IV_Properties;
SUBPROGRAM PI_update
PROPERTIES
  Taste::Associated_Queue_Size => 1;
END PI_update;

SUBPROGRAM IMPLEMENTATION PI_update.others
PROPERTIES
  Compute_Execution_Time => 0 ms .. 0 ms;
END PI_update.others;

SUBPROGRAM PI_commands
FEATURES
  cmds : IN PARAMETER DataView::Base_commands_Joints {
    Taste::encoding => NATIVE;
  };
PROPERTIES
  Taste::Associated_Queue_Size => 1;
END PI_commands;

SUBPROGRAM IMPLEMENTATION PI_commands.others
PROPERTIES
  Compute_Execution_Time => 0 ms .. 0 ms;
END PI_commands.others;

SUBPROGRAM RI_samples
FEATURES
  smpls : IN PARAMETER DataView::Base_commands_Joints {
    Taste::encoding => NATIVE;
  };
END RI_samples;

SUBPROGRAM IMPLEMENTATION RI_samples.others
END RI_samples.others;

END interfaceview::FV::gr740_candriver;

PACKAGE interfaceview::FV::candriver_test
PUBLIC

WITH Taste;
WITH DataView;
WITH TASTE_IV_Properties;
SUBPROGRAM PI_samples
FEATURES
  smpls : IN PARAMETER DataView::Base_commands_Joints {
    Taste::encoding => NATIVE;
  };
PROPERTIES
  Taste::Associated_Queue_Size => 1;
END PI_samples;

SUBPROGRAM IMPLEMENTATION PI_samples.others
PROPERTIES
  Compute_Execution_Time => 0 ms .. 0 ms;
END PI_samples.others;

SUBPROGRAM RI_commands
FEATURES
  cmds : IN PARAMETER DataView::Base_commands_Joints {
    Taste::encoding => NATIVE;
  };
END RI_commands;

SUBPROGRAM IMPLEMENTATION RI_commands.others
END RI_commands.others;

END interfaceview::FV::candriver_test;

PACKAGE interfaceview::IV
PUBLIC

WITH interfaceview::FV::candriver_test;
WITH interfaceview::FV::gr740_candriver;
WITH Taste;
WITH DataView;
WITH TASTE_IV_Properties;
SYSTEM gr740_candriver
FEATURES
  PI_update : PROVIDES SUBPROGRAM ACCESS interfaceview::FV::gr740_candriver::PI_update.others {
    Taste::coordinates => "106454 72283";
    Taste::RCMoperationKind => cyclic;
    Taste::RCMperiod => 1000 ms;
    Taste::Deadline => 0 ms;
    Taste::InterfaceName => "update";
  };
  PI_commands : PROVIDES SUBPROGRAM ACCESS interfaceview::FV::gr740_candriver::PI_commands.others {
    Taste::coordinates => "106454 56380";
    Taste::RCMoperationKind => sporadic;
    Taste::RCMperiod => 0 ms;
    Taste::Deadline => 0 ms;
    Taste::InterfaceName => "commands";
  };
  RI_samples : REQUIRES SUBPROGRAM ACCESS interfaceview::FV::candriver_test::PI_samples.others {
    Taste::coordinates => "106454 77010";
    Taste::RCMoperationKind => any;
    Taste::InterfaceName => "samples";
    Taste::labelInheritance => "false";
  };
PROPERTIES
  Source_Language => (C);
  Taste::Active_Interfaces => any;
  Source_Text => ("gr740_candriver.zip");
END gr740_candriver;

SYSTEM IMPLEMENTATION gr740_candriver.others
SUBCOMPONENTS
  flagsToCompileWith : DATA DataView::Taste_directive {
    Taste::FS_Default_Value => "compiler-option: ""-I/opt/rtems-5.1-2018.03.08/sparc-rtems5/gr740/lib/include -DCONFIGURE_DRIVER_AMBAPP_GAISLER_GRCAN""";
  };
  update_impl : SUBPROGRAM interfaceview::FV::gr740_candriver::PI_update.others;
  commands_impl : SUBPROGRAM interfaceview::FV::gr740_candriver::PI_commands.others;
CONNECTIONS
  OpToPICnx_update_impl : SUBPROGRAM ACCESS update_impl -> PI_update;
  OpToPICnx_commands_impl : SUBPROGRAM ACCESS commands_impl -> PI_commands;
END gr740_candriver.others;

SYSTEM candriver_test
FEATURES
  PI_samples : PROVIDES SUBPROGRAM ACCESS interfaceview::FV::candriver_test::PI_samples.others {
    Taste::coordinates => "75903 77641";
    Taste::RCMoperationKind => sporadic;
    Taste::RCMperiod => 0 ms;
    Taste::Deadline => 0 ms;
    Taste::InterfaceName => "samples";
  };
  RI_commands : REQUIRES SUBPROGRAM ACCESS interfaceview::FV::gr740_candriver::PI_commands.others {
    Taste::coordinates => "75903 56220";
    Taste::RCMoperationKind => any;
    Taste::InterfaceName => "commands";
    Taste::labelInheritance => "true";
  };
PROPERTIES
  Source_Language => (C);
  Taste::Active_Interfaces => any;
END candriver_test;

SYSTEM IMPLEMENTATION candriver_test.others
SUBCOMPONENTS
  samples_impl : SUBPROGRAM interfaceview::FV::candriver_test::PI_samples.others;
CONNECTIONS
  OpToPICnx_samples_impl : SUBPROGRAM ACCESS samples_impl -> PI_samples;
END candriver_test.others;

SYSTEM interfaceview
PROPERTIES
  Taste::dataView => ("DataView");
  Taste::dataViewPath => ("gr740-candriver_dv.aadl");
END interfaceview;

SYSTEM IMPLEMENTATION interfaceview.others
SUBCOMPONENTS
  gr740_candriver : SYSTEM interfaceview::IV::gr740_candriver.others {
    Taste::coordinates => "106454 48660 149445 82517";
  };
  candriver_test : SYSTEM interfaceview::IV::candriver_test.others {
    Taste::coordinates => "31495 48346 75903 82675";
  };
CONNECTIONS
  gr740_candriver_PI_commands_candriver_test_RI_commands : SUBPROGRAM ACCESS gr740_candriver.PI_commands -> candriver_test.RI_commands {
    Taste::coordinates => "75903 56220 91178 56220 91178 56380 106454 56380";
  };
  candriver_test_PI_samples_gr740_candriver_RI_samples : SUBPROGRAM ACCESS candriver_test.PI_samples -> gr740_candriver.RI_samples {
    Taste::coordinates => "106454 77010 91178 77010 91178 77641 75903 77641";
  };
END interfaceview.others;

PROPERTIES
  Taste::dataView => ("DataView");
  Taste::dataViewPath => ("gr740-candriver_dv.aadl");
  Taste::coordinates => "0 0 297000 210000";
  Taste::version => "1.3";
END interfaceview::IV;




---------------------------------------------------
-- AADL2.1
-- TASTE type deploymentview
-- 
-- generated code: do not edit
---------------------------------------------------

PACKAGE deploymentview::DV::Node1
PUBLIC

WITH Taste;
WITH Deployment;
WITH TASTE_DV_Properties;
PROCESS gr740_partition
END gr740_partition;

PROCESS IMPLEMENTATION gr740_partition.others
END gr740_partition.others;

END deploymentview::DV::Node1;

PACKAGE deploymentview::DV
PUBLIC

WITH interfaceview::IV;
WITH ocarina_processors_leon;
WITH deploymentview::DV::Node1;
WITH Taste;
WITH Deployment;
WITH interfaceview::IV;
WITH TASTE_DV_Properties;
SYSTEM Node1
END Node1;

SYSTEM IMPLEMENTATION Node1.others
SUBCOMPONENTS
  IV_gr740_candriver : SYSTEM interfaceview::IV::gr740_candriver.others {
    Taste::FunctionName => "gr740_candriver";
  };
  IV_candriver_test : SYSTEM interfaceview::IV::candriver_test.others {
    Taste::FunctionName => "candriver_test";
  };
  gr740_partition : PROCESS deploymentview::DV::Node1::gr740_partition.others {
    Taste::coordinates => "132081 77242 166651 106178";
    Deployment::Port_Number => 0;
  };
  gr740_rtems51_posix : PROCESSOR ocarina_processors_leon::gr740.rtems51_posix {
    Taste::coordinates => "127760 68975 170972 110312";
  };
PROPERTIES
  Taste::APLC_Binding => (reference (gr740_partition)) APPLIES TO IV_gr740_candriver;
  Taste::APLC_Binding => (reference (gr740_partition)) APPLIES TO IV_candriver_test;
  Actual_Processor_Binding => (reference (gr740_rtems51_posix)) APPLIES TO gr740_partition;
END Node1.others;

SYSTEM deploymentview
END deploymentview;

SYSTEM IMPLEMENTATION deploymentview.others
SUBCOMPONENTS
  Node1 : SYSTEM Node1.others {
    Taste::coordinates => "122359 57164 176373 116217";
  };
  interfaceview : SYSTEM interfaceview::IV::interfaceview.others;
END deploymentview.others;

PROPERTIES
  Taste::coordinates => "0 0 297000 210000";
  Taste::version => "1.3";
  Taste::interfaceView => "gr740-candriver_iv.aadl";
  Taste::HWLibraries => ("../../../tool-inst/share/ocarina/AADLv2/ocarina_components.aadl");
END deploymentview::DV;




--------------------------------------------------------
--! File generated by asn2aadl v2.1.18: DO NOT EDIT !
--------------------------------------------------------
--! InputASN1FileChecksum:ee553fef5f73529fe765d3e645b11923:/home/taste/esrocos_workspace/install/types/base/userdefs-base.asn:
--! InputASN1FileChecksum:e6f80d8efd7e00de52c238edf66056b0:/home/taste/esrocos_workspace/install/types/base/taste-extended.asn:
--! InputASN1FileChecksum:5831472ee4b55e91787887a6d0834166:/home/taste/esrocos_workspace/install/types/base/base.asn:
--! InputASN1FileChecksum:4700ece06fd3ee1dd3f6cbde3caba96e:/home/taste/esrocos_workspace/install/types/base/taste-types.asn:
--------------------------------------------------------

package DataView

public

DATA Wrappers_AngleAxisd
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 53; suggested aligned message buffer is...
    Source_Data_Size => 56 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Wrappers-AngleAxisd";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Wrappers_AngleAxisd;

DATA IMPLEMENTATION Wrappers_AngleAxisd.impl
END Wrappers_AngleAxisd.impl;

DATA Wrappers_AngleAxisd_Buffer_Max
END Wrappers_AngleAxisd_Buffer_Max;

DATA IMPLEMENTATION Wrappers_AngleAxisd_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Wrappers_AngleAxisd
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (56); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Wrappers_AngleAxisd_Buffer_Max.impl;

DATA Wrappers_AngleAxisd_Buffer
END Wrappers_AngleAxisd_Buffer;

DATA IMPLEMENTATION Wrappers_AngleAxisd_Buffer.impl
    -- Buffer to hold a marshalled data of type Wrappers_AngleAxisd
SUBCOMPONENTS
    Buffer : data Wrappers_AngleAxisd_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Wrappers_AngleAxisd_Buffer.impl;

DATA Wrappers_Matrix6d
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 469; suggested aligned message buffer is...
    Source_Data_Size => 472 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Wrappers-Matrix6d";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Wrappers_Matrix6d;

DATA IMPLEMENTATION Wrappers_Matrix6d.impl
END Wrappers_Matrix6d.impl;

DATA Wrappers_Matrix6d_Buffer_Max
END Wrappers_Matrix6d_Buffer_Max;

DATA IMPLEMENTATION Wrappers_Matrix6d_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Wrappers_Matrix6d
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (472); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Wrappers_Matrix6d_Buffer_Max.impl;

DATA Wrappers_Matrix6d_Buffer
END Wrappers_Matrix6d_Buffer;

DATA IMPLEMENTATION Wrappers_Matrix6d_Buffer.impl
    -- Buffer to hold a marshalled data of type Wrappers_Matrix6d
SUBCOMPONENTS
    Buffer : data Wrappers_Matrix6d_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Wrappers_Matrix6d_Buffer.impl;

DATA T_Time
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/taste-extended.asn");
    Ada_Package_Name => "TASTE_ExtendedTypes";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 16; suggested aligned message buffer is...
    Source_Data_Size => 16 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "T-Time";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END T_Time;

DATA IMPLEMENTATION T_Time.impl
END T_Time.impl;

DATA T_Time_Buffer_Max
END T_Time_Buffer_Max;

DATA IMPLEMENTATION T_Time_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type T_Time
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (16); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END T_Time_Buffer_Max.impl;

DATA T_Time_Buffer
END T_Time_Buffer;

DATA IMPLEMENTATION T_Time_Buffer.impl
    -- Buffer to hold a marshalled data of type T_Time
SUBCOMPONENTS
    Buffer : data T_Time_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END T_Time_Buffer.impl;

DATA T_String
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/taste-extended.asn");
    Ada_Package_Name => "TASTE_ExtendedTypes";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 204; suggested aligned message buffer is...
    Source_Data_Size => 208 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "T-String";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSTRING;
END T_String;

DATA IMPLEMENTATION T_String.impl
END T_String.impl;

DATA T_String_Buffer_Max
END T_String_Buffer_Max;

DATA IMPLEMENTATION T_String_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type T_String
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (208); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END T_String_Buffer_Max.impl;

DATA T_String_Buffer
END T_String_Buffer;

DATA IMPLEMENTATION T_String_Buffer.impl
    -- Buffer to hold a marshalled data of type T_String
SUBCOMPONENTS
    Buffer : data T_String_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END T_String_Buffer.impl;

DATA Base_geometry_SplineBase_CoordinateType
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 4; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-geometry-SplineBase-CoordinateType";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aENUMERATED;
END Base_geometry_SplineBase_CoordinateType;

DATA IMPLEMENTATION Base_geometry_SplineBase_CoordinateType.impl
END Base_geometry_SplineBase_CoordinateType.impl;

DATA Base_geometry_SplineBase_CoordinateType_Buffer_Max
END Base_geometry_SplineBase_CoordinateType_Buffer_Max;

DATA IMPLEMENTATION Base_geometry_SplineBase_CoordinateType_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_geometry_SplineBase_CoordinateType
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_geometry_SplineBase_CoordinateType_Buffer_Max.impl;

DATA Base_geometry_SplineBase_CoordinateType_Buffer
END Base_geometry_SplineBase_CoordinateType_Buffer;

DATA IMPLEMENTATION Base_geometry_SplineBase_CoordinateType_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_geometry_SplineBase_CoordinateType
SUBCOMPONENTS
    Buffer : data Base_geometry_SplineBase_CoordinateType_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_geometry_SplineBase_CoordinateType_Buffer.impl;

DATA Wrappers_Vector2d
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 27; suggested aligned message buffer is...
    Source_Data_Size => 32 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Wrappers-Vector2d";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Wrappers_Vector2d;

DATA IMPLEMENTATION Wrappers_Vector2d.impl
END Wrappers_Vector2d.impl;

DATA Wrappers_Vector2d_Buffer_Max
END Wrappers_Vector2d_Buffer_Max;

DATA IMPLEMENTATION Wrappers_Vector2d_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Wrappers_Vector2d
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (32); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Wrappers_Vector2d_Buffer_Max.impl;

DATA Wrappers_Vector2d_Buffer
END Wrappers_Vector2d_Buffer;

DATA IMPLEMENTATION Wrappers_Vector2d_Buffer.impl
    -- Buffer to hold a marshalled data of type Wrappers_Vector2d
SUBCOMPONENTS
    Buffer : data Wrappers_Vector2d_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Wrappers_Vector2d_Buffer.impl;

DATA Base_JointTransformVector_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 128816; suggested aligned message buffer is...
    Source_Data_Size => 128816 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-JointTransformVector-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_JointTransformVector_m;

DATA IMPLEMENTATION Base_JointTransformVector_m.impl
END Base_JointTransformVector_m.impl;

DATA Base_JointTransformVector_m_Buffer_Max
END Base_JointTransformVector_m_Buffer_Max;

DATA IMPLEMENTATION Base_JointTransformVector_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_JointTransformVector_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (128816); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_JointTransformVector_m_Buffer_Max.impl;

DATA Base_JointTransformVector_m_Buffer
END Base_JointTransformVector_m_Buffer;

DATA IMPLEMENTATION Base_JointTransformVector_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_JointTransformVector_m
SUBCOMPONENTS
    Buffer : data Base_JointTransformVector_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_JointTransformVector_m_Buffer.impl;

DATA Base_samples_frame_FramePair
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 163760; suggested aligned message buffer is...
    Source_Data_Size => 163760 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-frame-FramePair";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_frame_FramePair;

DATA IMPLEMENTATION Base_samples_frame_FramePair.impl
END Base_samples_frame_FramePair.impl;

DATA Base_samples_frame_FramePair_Buffer_Max
END Base_samples_frame_FramePair_Buffer_Max;

DATA IMPLEMENTATION Base_samples_frame_FramePair_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_frame_FramePair
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (163760); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_frame_FramePair_Buffer_Max.impl;

DATA Base_samples_frame_FramePair_Buffer
END Base_samples_frame_FramePair_Buffer;

DATA IMPLEMENTATION Base_samples_frame_FramePair_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_frame_FramePair
SUBCOMPONENTS
    Buffer : data Base_samples_frame_FramePair_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_frame_FramePair_Buffer.impl;

DATA Base_Time
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 8; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-Time";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_Time;

DATA IMPLEMENTATION Base_Time.impl
END Base_Time.impl;

DATA Base_Time_Buffer_Max
END Base_Time_Buffer_Max;

DATA IMPLEMENTATION Base_Time_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_Time
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_Time_Buffer_Max.impl;

DATA Base_Time_Buffer
END Base_Time_Buffer;

DATA IMPLEMENTATION Base_Time_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_Time
SUBCOMPONENTS
    Buffer : data Base_Time_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_Time_Buffer.impl;

DATA Base_Temperature
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 13; suggested aligned message buffer is...
    Source_Data_Size => 16 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-Temperature";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_Temperature;

DATA IMPLEMENTATION Base_Temperature.impl
END Base_Temperature.impl;

DATA Base_Temperature_Buffer_Max
END Base_Temperature_Buffer_Max;

DATA IMPLEMENTATION Base_Temperature_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_Temperature
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (16); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_Temperature_Buffer_Max.impl;

DATA Base_Temperature_Buffer
END Base_Temperature_Buffer;

DATA IMPLEMENTATION Base_Temperature_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_Temperature
SUBCOMPONENTS
    Buffer : data Base_Temperature_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_Temperature_Buffer.impl;

DATA Wrappers_VectorXd
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 2601; suggested aligned message buffer is...
    Source_Data_Size => 2608 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Wrappers-VectorXd";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Wrappers_VectorXd;

DATA IMPLEMENTATION Wrappers_VectorXd.impl
END Wrappers_VectorXd.impl;

DATA Wrappers_VectorXd_Buffer_Max
END Wrappers_VectorXd_Buffer_Max;

DATA IMPLEMENTATION Wrappers_VectorXd_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Wrappers_VectorXd
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (2608); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Wrappers_VectorXd_Buffer_Max.impl;

DATA Wrappers_VectorXd_Buffer
END Wrappers_VectorXd_Buffer;

DATA IMPLEMENTATION Wrappers_VectorXd_Buffer.impl
    -- Buffer to hold a marshalled data of type Wrappers_VectorXd
SUBCOMPONENTS
    Buffer : data Wrappers_VectorXd_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Wrappers_VectorXd_Buffer.impl;

DATA Base_TwistWithCovariance_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 548; suggested aligned message buffer is...
    Source_Data_Size => 552 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-TwistWithCovariance-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_TwistWithCovariance_m;

DATA IMPLEMENTATION Base_TwistWithCovariance_m.impl
END Base_TwistWithCovariance_m.impl;

DATA Base_TwistWithCovariance_m_Buffer_Max
END Base_TwistWithCovariance_m_Buffer_Max;

DATA IMPLEMENTATION Base_TwistWithCovariance_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_TwistWithCovariance_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (552); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_TwistWithCovariance_m_Buffer_Max.impl;

DATA Base_TwistWithCovariance_m_Buffer
END Base_TwistWithCovariance_m_Buffer;

DATA IMPLEMENTATION Base_TwistWithCovariance_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_TwistWithCovariance_m
SUBCOMPONENTS
    Buffer : data Base_TwistWithCovariance_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_TwistWithCovariance_m_Buffer.impl;

DATA Base_Waypoint
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 79; suggested aligned message buffer is...
    Source_Data_Size => 80 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-Waypoint";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_Waypoint;

DATA IMPLEMENTATION Base_Waypoint.impl
END Base_Waypoint.impl;

DATA Base_Waypoint_Buffer_Max
END Base_Waypoint_Buffer_Max;

DATA IMPLEMENTATION Base_Waypoint_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_Waypoint
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (80); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_Waypoint_Buffer_Max.impl;

DATA Base_Waypoint_Buffer
END Base_Waypoint_Buffer;

DATA IMPLEMENTATION Base_Waypoint_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_Waypoint
SUBCOMPONENTS
    Buffer : data Base_Waypoint_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_Waypoint_Buffer.impl;

DATA Dummy2Base_T
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 8; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Dummy2Base-T";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aINTEGER;
END Dummy2Base_T;

DATA IMPLEMENTATION Dummy2Base_T.impl
END Dummy2Base_T.impl;

DATA Dummy2Base_T_Buffer_Max
END Dummy2Base_T_Buffer_Max;

DATA IMPLEMENTATION Dummy2Base_T_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Dummy2Base_T
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Dummy2Base_T_Buffer_Max.impl;

DATA Dummy2Base_T_Buffer
END Dummy2Base_T_Buffer;

DATA IMPLEMENTATION Dummy2Base_T_Buffer.impl
    -- Buffer to hold a marshalled data of type Dummy2Base_T
SUBCOMPONENTS
    Buffer : data Dummy2Base_T_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Dummy2Base_T_Buffer.impl;

DATA Base_Pose
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 92; suggested aligned message buffer is...
    Source_Data_Size => 96 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-Pose";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_Pose;

DATA IMPLEMENTATION Base_Pose.impl
END Base_Pose.impl;

DATA Base_Pose_Buffer_Max
END Base_Pose_Buffer_Max;

DATA IMPLEMENTATION Base_Pose_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_Pose
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (96); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_Pose_Buffer_Max.impl;

DATA Base_Pose_Buffer
END Base_Pose_Buffer;

DATA IMPLEMENTATION Base_Pose_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_Pose
SUBCOMPONENTS
    Buffer : data Base_Pose_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_Pose_Buffer.impl;

DATA Base_JointLimitRange
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 130; suggested aligned message buffer is...
    Source_Data_Size => 136 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-JointLimitRange";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_JointLimitRange;

DATA IMPLEMENTATION Base_JointLimitRange.impl
END Base_JointLimitRange.impl;

DATA Base_JointLimitRange_Buffer_Max
END Base_JointLimitRange_Buffer_Max;

DATA IMPLEMENTATION Base_JointLimitRange_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_JointLimitRange
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (136); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_JointLimitRange_Buffer_Max.impl;

DATA Base_JointLimitRange_Buffer
END Base_JointLimitRange_Buffer;

DATA IMPLEMENTATION Base_JointLimitRange_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_JointLimitRange
SUBCOMPONENTS
    Buffer : data Base_JointLimitRange_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_JointLimitRange_Buffer.impl;

DATA Base_samples_frame_Frame
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 81872; suggested aligned message buffer is...
    Source_Data_Size => 81872 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-frame-Frame";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_frame_Frame;

DATA IMPLEMENTATION Base_samples_frame_Frame.impl
END Base_samples_frame_Frame.impl;

DATA Base_samples_frame_Frame_Buffer_Max
END Base_samples_frame_Frame_Buffer_Max;

DATA IMPLEMENTATION Base_samples_frame_Frame_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_frame_Frame
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (81872); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_frame_Frame_Buffer_Max.impl;

DATA Base_samples_frame_Frame_Buffer
END Base_samples_frame_Frame_Buffer;

DATA IMPLEMENTATION Base_samples_frame_Frame_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_frame_Frame
SUBCOMPONENTS
    Buffer : data Base_samples_frame_Frame_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_frame_Frame_Buffer.impl;

DATA Base_samples_Pointcloud_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 18310; suggested aligned message buffer is...
    Source_Data_Size => 18312 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-Pointcloud-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_Pointcloud_m;

DATA IMPLEMENTATION Base_samples_Pointcloud_m.impl
END Base_samples_Pointcloud_m.impl;

DATA Base_samples_Pointcloud_m_Buffer_Max
END Base_samples_Pointcloud_m_Buffer_Max;

DATA IMPLEMENTATION Base_samples_Pointcloud_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_Pointcloud_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (18312); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_Pointcloud_m_Buffer_Max.impl;

DATA Base_samples_Pointcloud_m_Buffer
END Base_samples_Pointcloud_m_Buffer;

DATA IMPLEMENTATION Base_samples_Pointcloud_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_Pointcloud_m
SUBCOMPONENTS
    Buffer : data Base_samples_Pointcloud_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_Pointcloud_m_Buffer.impl;

DATA Base_Wrench
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 79; suggested aligned message buffer is...
    Source_Data_Size => 80 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-Wrench";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_Wrench;

DATA IMPLEMENTATION Base_Wrench.impl
END Base_Wrench.impl;

DATA Base_Wrench_Buffer_Max
END Base_Wrench_Buffer_Max;

DATA IMPLEMENTATION Base_Wrench_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_Wrench
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (80); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_Wrench_Buffer_Max.impl;

DATA Base_Wrench_Buffer
END Base_Wrench_Buffer;

DATA IMPLEMENTATION Base_Wrench_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_Wrench
SUBCOMPONENTS
    Buffer : data Base_Wrench_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_Wrench_Buffer.impl;

DATA T_Float
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/taste-extended.asn");
    Ada_Package_Name => "TASTE_ExtendedTypes";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 13; suggested aligned message buffer is...
    Source_Data_Size => 16 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "T-Float";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aREAL;
END T_Float;

DATA IMPLEMENTATION T_Float.impl
END T_Float.impl;

DATA T_Float_Buffer_Max
END T_Float_Buffer_Max;

DATA IMPLEMENTATION T_Float_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type T_Float
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (16); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END T_Float_Buffer_Max.impl;

DATA T_Float_Buffer
END T_Float_Buffer;

DATA IMPLEMENTATION T_Float_Buffer.impl
    -- Buffer to hold a marshalled data of type T_Float
SUBCOMPONENTS
    Buffer : data T_Float_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END T_Float_Buffer.impl;

DATA Base_samples_IMUSensors
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 126; suggested aligned message buffer is...
    Source_Data_Size => 128 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-IMUSensors";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_IMUSensors;

DATA IMPLEMENTATION Base_samples_IMUSensors.impl
END Base_samples_IMUSensors.impl;

DATA Base_samples_IMUSensors_Buffer_Max
END Base_samples_IMUSensors_Buffer_Max;

DATA IMPLEMENTATION Base_samples_IMUSensors_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_IMUSensors
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (128); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_IMUSensors_Buffer_Max.impl;

DATA Base_samples_IMUSensors_Buffer
END Base_samples_IMUSensors_Buffer;

DATA IMPLEMENTATION Base_samples_IMUSensors_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_IMUSensors
SUBCOMPONENTS
    Buffer : data Base_samples_IMUSensors_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_IMUSensors_Buffer.impl;

DATA Base_samples_SonarScan
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 1896; suggested aligned message buffer is...
    Source_Data_Size => 1896 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-SonarScan";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_SonarScan;

DATA IMPLEMENTATION Base_samples_SonarScan.impl
END Base_samples_SonarScan.impl;

DATA Base_samples_SonarScan_Buffer_Max
END Base_samples_SonarScan_Buffer_Max;

DATA IMPLEMENTATION Base_samples_SonarScan_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_SonarScan
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (1896); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_SonarScan_Buffer_Max.impl;

DATA Base_samples_SonarScan_Buffer
END Base_samples_SonarScan_Buffer;

DATA IMPLEMENTATION Base_samples_SonarScan_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_SonarScan
SUBCOMPONENTS
    Buffer : data Base_samples_SonarScan_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_SonarScan_Buffer.impl;

DATA Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 4; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-DepthMap-DEPTH-MEASUREMENT-STATE";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aENUMERATED;
END Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE;

DATA IMPLEMENTATION Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE.impl
END Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE.impl;

DATA Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Buffer_Max
END Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Buffer_Max;

DATA IMPLEMENTATION Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Buffer_Max.impl;

DATA Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Buffer
END Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Buffer;

DATA IMPLEMENTATION Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE
SUBCOMPONENTS
    Buffer : data Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Buffer.impl;

DATA Base_samples_RigidBodyState
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 1050; suggested aligned message buffer is...
    Source_Data_Size => 1056 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-RigidBodyState";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_RigidBodyState;

DATA IMPLEMENTATION Base_samples_RigidBodyState.impl
END Base_samples_RigidBodyState.impl;

DATA Base_samples_RigidBodyState_Buffer_Max
END Base_samples_RigidBodyState_Buffer_Max;

DATA IMPLEMENTATION Base_samples_RigidBodyState_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_RigidBodyState
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (1056); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_RigidBodyState_Buffer_Max.impl;

DATA Base_samples_RigidBodyState_Buffer
END Base_samples_RigidBodyState_Buffer;

DATA IMPLEMENTATION Base_samples_RigidBodyState_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_RigidBodyState
SUBCOMPONENTS
    Buffer : data Base_samples_RigidBodyState_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_RigidBodyState_Buffer.impl;

DATA Base_NamedVector_Base_Wrench
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 55902; suggested aligned message buffer is...
    Source_Data_Size => 55904 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-NamedVector-Base-Wrench";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_NamedVector_Base_Wrench;

DATA IMPLEMENTATION Base_NamedVector_Base_Wrench.impl
END Base_NamedVector_Base_Wrench.impl;

DATA Base_NamedVector_Base_Wrench_Buffer_Max
END Base_NamedVector_Base_Wrench_Buffer_Max;

DATA IMPLEMENTATION Base_NamedVector_Base_Wrench_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_NamedVector_Base_Wrench
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (55904); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_NamedVector_Base_Wrench_Buffer_Max.impl;

DATA Base_NamedVector_Base_Wrench_Buffer
END Base_NamedVector_Base_Wrench_Buffer;

DATA IMPLEMENTATION Base_NamedVector_Base_Wrench_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_NamedVector_Base_Wrench
SUBCOMPONENTS
    Buffer : data Base_NamedVector_Base_Wrench_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_NamedVector_Base_Wrench_Buffer.impl;

DATA T_Double
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/taste-extended.asn");
    Ada_Package_Name => "TASTE_ExtendedTypes";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 13; suggested aligned message buffer is...
    Source_Data_Size => 16 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "T-Double";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aREAL;
END T_Double;

DATA IMPLEMENTATION T_Double.impl
END T_Double.impl;

DATA T_Double_Buffer_Max
END T_Double_Buffer_Max;

DATA IMPLEMENTATION T_Double_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type T_Double
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (16); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END T_Double_Buffer_Max.impl;

DATA T_Double_Buffer
END T_Double_Buffer;

DATA IMPLEMENTATION T_Double_Buffer.impl
    -- Buffer to hold a marshalled data of type T_Double
SUBCOMPONENTS
    Buffer : data T_Double_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END T_Double_Buffer.impl;

DATA Base_JointState_MODE
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 4; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-JointState-MODE";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aENUMERATED;
END Base_JointState_MODE;

DATA IMPLEMENTATION Base_JointState_MODE.impl
END Base_JointState_MODE.impl;

DATA Base_JointState_MODE_Buffer_Max
END Base_JointState_MODE_Buffer_Max;

DATA IMPLEMENTATION Base_JointState_MODE_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_JointState_MODE
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_JointState_MODE_Buffer_Max.impl;

DATA Base_JointState_MODE_Buffer
END Base_JointState_MODE_Buffer;

DATA IMPLEMENTATION Base_JointState_MODE_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_JointState_MODE
SUBCOMPONENTS
    Buffer : data Base_JointState_MODE_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_JointState_MODE_Buffer.impl;

DATA Base_samples_DistanceImage
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 2665; suggested aligned message buffer is...
    Source_Data_Size => 2672 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-DistanceImage";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_DistanceImage;

DATA IMPLEMENTATION Base_samples_DistanceImage.impl
END Base_samples_DistanceImage.impl;

DATA Base_samples_DistanceImage_Buffer_Max
END Base_samples_DistanceImage_Buffer_Max;

DATA IMPLEMENTATION Base_samples_DistanceImage_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_DistanceImage
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (2672); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_DistanceImage_Buffer_Max.impl;

DATA Base_samples_DistanceImage_Buffer
END Base_samples_DistanceImage_Buffer;

DATA IMPLEMENTATION Base_samples_DistanceImage_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_DistanceImage
SUBCOMPONENTS
    Buffer : data Base_samples_DistanceImage_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_DistanceImage_Buffer.impl;

DATA Base_samples_RigidBodyAcceleration
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 322; suggested aligned message buffer is...
    Source_Data_Size => 328 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-RigidBodyAcceleration";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_RigidBodyAcceleration;

DATA IMPLEMENTATION Base_samples_RigidBodyAcceleration.impl
END Base_samples_RigidBodyAcceleration.impl;

DATA Base_samples_RigidBodyAcceleration_Buffer_Max
END Base_samples_RigidBodyAcceleration_Buffer_Max;

DATA IMPLEMENTATION Base_samples_RigidBodyAcceleration_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_RigidBodyAcceleration
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (328); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_RigidBodyAcceleration_Buffer_Max.impl;

DATA Base_samples_RigidBodyAcceleration_Buffer
END Base_samples_RigidBodyAcceleration_Buffer;

DATA IMPLEMENTATION Base_samples_RigidBodyAcceleration_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_RigidBodyAcceleration
SUBCOMPONENTS
    Buffer : data Base_samples_RigidBodyAcceleration_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_RigidBodyAcceleration_Buffer.impl;

DATA Base_JointTransformVector
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 128816; suggested aligned message buffer is...
    Source_Data_Size => 128816 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-JointTransformVector";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_JointTransformVector;

DATA IMPLEMENTATION Base_JointTransformVector.impl
END Base_JointTransformVector.impl;

DATA Base_JointTransformVector_Buffer_Max
END Base_JointTransformVector_Buffer_Max;

DATA IMPLEMENTATION Base_JointTransformVector_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_JointTransformVector
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (128816); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_JointTransformVector_Buffer_Max.impl;

DATA Base_JointTransformVector_Buffer
END Base_JointTransformVector_Buffer;

DATA IMPLEMENTATION Base_JointTransformVector_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_JointTransformVector
SUBCOMPONENTS
    Buffer : data Base_JointTransformVector_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_JointTransformVector_Buffer.impl;

DATA Base_Pose_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 92; suggested aligned message buffer is...
    Source_Data_Size => 96 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-Pose-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_Pose_m;

DATA IMPLEMENTATION Base_Pose_m.impl
END Base_Pose_m.impl;

DATA Base_Pose_m_Buffer_Max
END Base_Pose_m_Buffer_Max;

DATA IMPLEMENTATION Base_Pose_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_Pose_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (96); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_Pose_m_Buffer_Max.impl;

DATA Base_Pose_m_Buffer
END Base_Pose_m_Buffer;

DATA IMPLEMENTATION Base_Pose_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_Pose_m
SUBCOMPONENTS
    Buffer : data Base_Pose_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_Pose_m_Buffer.impl;

DATA Base_samples_BodyState_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 1116; suggested aligned message buffer is...
    Source_Data_Size => 1120 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-BodyState-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_BodyState_m;

DATA IMPLEMENTATION Base_samples_BodyState_m.impl
END Base_samples_BodyState_m.impl;

DATA Base_samples_BodyState_m_Buffer_Max
END Base_samples_BodyState_m_Buffer_Max;

DATA IMPLEMENTATION Base_samples_BodyState_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_BodyState_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (1120); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_BodyState_m_Buffer_Max.impl;

DATA Base_samples_BodyState_m_Buffer
END Base_samples_BodyState_m_Buffer;

DATA IMPLEMENTATION Base_samples_BodyState_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_BodyState_m
SUBCOMPONENTS
    Buffer : data Base_samples_BodyState_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_BodyState_m_Buffer.impl;

DATA Base_Pose2D
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 40; suggested aligned message buffer is...
    Source_Data_Size => 40 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-Pose2D";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_Pose2D;

DATA IMPLEMENTATION Base_Pose2D.impl
END Base_Pose2D.impl;

DATA Base_Pose2D_Buffer_Max
END Base_Pose2D_Buffer_Max;

DATA IMPLEMENTATION Base_Pose2D_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_Pose2D
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (40); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_Pose2D_Buffer_Max.impl;

DATA Base_Pose2D_Buffer
END Base_Pose2D_Buffer;

DATA IMPLEMENTATION Base_Pose2D_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_Pose2D
SUBCOMPONENTS
    Buffer : data Base_Pose2D_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_Pose2D_Buffer.impl;

DATA Base_NamedVector_base_JointTransform_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 128816; suggested aligned message buffer is...
    Source_Data_Size => 128816 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-NamedVector-base-JointTransform-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_NamedVector_base_JointTransform_m;

DATA IMPLEMENTATION Base_NamedVector_base_JointTransform_m.impl
END Base_NamedVector_base_JointTransform_m.impl;

DATA Base_NamedVector_base_JointTransform_m_Buffer_Max
END Base_NamedVector_base_JointTransform_m_Buffer_Max;

DATA IMPLEMENTATION Base_NamedVector_base_JointTransform_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_NamedVector_base_JointTransform_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (128816); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_NamedVector_base_JointTransform_m_Buffer_Max.impl;

DATA Base_NamedVector_base_JointTransform_m_Buffer
END Base_NamedVector_base_JointTransform_m_Buffer;

DATA IMPLEMENTATION Base_NamedVector_base_JointTransform_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_NamedVector_base_JointTransform_m
SUBCOMPONENTS
    Buffer : data Base_NamedVector_base_JointTransform_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_NamedVector_base_JointTransform_m_Buffer.impl;

DATA Base_Angle
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 13; suggested aligned message buffer is...
    Source_Data_Size => 16 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-Angle";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_Angle;

DATA IMPLEMENTATION Base_Angle.impl
END Base_Angle.impl;

DATA Base_Angle_Buffer_Max
END Base_Angle_Buffer_Max;

DATA IMPLEMENTATION Base_Angle_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_Angle
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (16); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_Angle_Buffer_Max.impl;

DATA Base_Angle_Buffer
END Base_Angle_Buffer;

DATA IMPLEMENTATION Base_Angle_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_Angle
SUBCOMPONENTS
    Buffer : data Base_Angle_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_Angle_Buffer.impl;

DATA Base_TwistWithCovariance
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 548; suggested aligned message buffer is...
    Source_Data_Size => 552 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-TwistWithCovariance";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_TwistWithCovariance;

DATA IMPLEMENTATION Base_TwistWithCovariance.impl
END Base_TwistWithCovariance.impl;

DATA Base_TwistWithCovariance_Buffer_Max
END Base_TwistWithCovariance_Buffer_Max;

DATA IMPLEMENTATION Base_TwistWithCovariance_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_TwistWithCovariance
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (552); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_TwistWithCovariance_Buffer_Max.impl;

DATA Base_TwistWithCovariance_Buffer
END Base_TwistWithCovariance_Buffer;

DATA IMPLEMENTATION Base_TwistWithCovariance_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_TwistWithCovariance
SUBCOMPONENTS
    Buffer : data Base_TwistWithCovariance_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_TwistWithCovariance_Buffer.impl;

DATA Base_NamedVector_Base_JointState
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 53202; suggested aligned message buffer is...
    Source_Data_Size => 53208 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-NamedVector-Base-JointState";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_NamedVector_Base_JointState;

DATA IMPLEMENTATION Base_NamedVector_Base_JointState.impl
END Base_NamedVector_Base_JointState.impl;

DATA Base_NamedVector_Base_JointState_Buffer_Max
END Base_NamedVector_Base_JointState_Buffer_Max;

DATA IMPLEMENTATION Base_NamedVector_Base_JointState_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_NamedVector_Base_JointState
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (53208); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_NamedVector_Base_JointState_Buffer_Max.impl;

DATA Base_NamedVector_Base_JointState_Buffer
END Base_NamedVector_Base_JointState_Buffer;

DATA IMPLEMENTATION Base_NamedVector_Base_JointState_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_NamedVector_Base_JointState
SUBCOMPONENTS
    Buffer : data Base_NamedVector_Base_JointState_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_NamedVector_Base_JointState_Buffer.impl;

DATA Base_Pose2D_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 40; suggested aligned message buffer is...
    Source_Data_Size => 40 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-Pose2D-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_Pose2D_m;

DATA IMPLEMENTATION Base_Pose2D_m.impl
END Base_Pose2D_m.impl;

DATA Base_Pose2D_m_Buffer_Max
END Base_Pose2D_m_Buffer_Max;

DATA IMPLEMENTATION Base_Pose2D_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_Pose2D_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (40); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_Pose2D_m_Buffer_Max.impl;

DATA Base_Pose2D_m_Buffer
END Base_Pose2D_m_Buffer;

DATA IMPLEMENTATION Base_Pose2D_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_Pose2D_m
SUBCOMPONENTS
    Buffer : data Base_Pose2D_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_Pose2D_m_Buffer.impl;

DATA Base_samples_LASER_RANGE_ERRORS
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 4; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-LASER-RANGE-ERRORS";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aENUMERATED;
END Base_samples_LASER_RANGE_ERRORS;

DATA IMPLEMENTATION Base_samples_LASER_RANGE_ERRORS.impl
END Base_samples_LASER_RANGE_ERRORS.impl;

DATA Base_samples_LASER_RANGE_ERRORS_Buffer_Max
END Base_samples_LASER_RANGE_ERRORS_Buffer_Max;

DATA IMPLEMENTATION Base_samples_LASER_RANGE_ERRORS_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_LASER_RANGE_ERRORS
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_LASER_RANGE_ERRORS_Buffer_Max.impl;

DATA Base_samples_LASER_RANGE_ERRORS_Buffer
END Base_samples_LASER_RANGE_ERRORS_Buffer;

DATA IMPLEMENTATION Base_samples_LASER_RANGE_ERRORS_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_LASER_RANGE_ERRORS
SUBCOMPONENTS
    Buffer : data Base_samples_LASER_RANGE_ERRORS_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_LASER_RANGE_ERRORS_Buffer.impl;

DATA Base_samples_DepthMap_UNIT_AXIS
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 4; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-DepthMap-UNIT-AXIS";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aENUMERATED;
END Base_samples_DepthMap_UNIT_AXIS;

DATA IMPLEMENTATION Base_samples_DepthMap_UNIT_AXIS.impl
END Base_samples_DepthMap_UNIT_AXIS.impl;

DATA Base_samples_DepthMap_UNIT_AXIS_Buffer_Max
END Base_samples_DepthMap_UNIT_AXIS_Buffer_Max;

DATA IMPLEMENTATION Base_samples_DepthMap_UNIT_AXIS_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_DepthMap_UNIT_AXIS
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_DepthMap_UNIT_AXIS_Buffer_Max.impl;

DATA Base_samples_DepthMap_UNIT_AXIS_Buffer
END Base_samples_DepthMap_UNIT_AXIS_Buffer;

DATA IMPLEMENTATION Base_samples_DepthMap_UNIT_AXIS_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_DepthMap_UNIT_AXIS
SUBCOMPONENTS
    Buffer : data Base_samples_DepthMap_UNIT_AXIS_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_DepthMap_UNIT_AXIS_Buffer.impl;

DATA Base_Wrench_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 79; suggested aligned message buffer is...
    Source_Data_Size => 80 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-Wrench-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_Wrench_m;

DATA IMPLEMENTATION Base_Wrench_m.impl
END Base_Wrench_m.impl;

DATA Base_Wrench_m_Buffer_Max
END Base_Wrench_m_Buffer_Max;

DATA IMPLEMENTATION Base_Wrench_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_Wrench_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (80); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_Wrench_m_Buffer_Max.impl;

DATA Base_Wrench_m_Buffer
END Base_Wrench_m_Buffer;

DATA IMPLEMENTATION Base_Wrench_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_Wrench_m
SUBCOMPONENTS
    Buffer : data Base_Wrench_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_Wrench_m_Buffer.impl;

DATA Std_orogen_typekits_mtype_std_vector_base_Wrench
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 15701; suggested aligned message buffer is...
    Source_Data_Size => 15704 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Std-orogen-typekits-mtype-std-vector-base-Wrench";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCEOF;
END Std_orogen_typekits_mtype_std_vector_base_Wrench;

DATA IMPLEMENTATION Std_orogen_typekits_mtype_std_vector_base_Wrench.impl
END Std_orogen_typekits_mtype_std_vector_base_Wrench.impl;

DATA Std_orogen_typekits_mtype_std_vector_base_Wrench_Buffer_Max
END Std_orogen_typekits_mtype_std_vector_base_Wrench_Buffer_Max;

DATA IMPLEMENTATION Std_orogen_typekits_mtype_std_vector_base_Wrench_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Std_orogen_typekits_mtype_std_vector_base_Wrench
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (15704); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Std_orogen_typekits_mtype_std_vector_base_Wrench_Buffer_Max.impl;

DATA Std_orogen_typekits_mtype_std_vector_base_Wrench_Buffer
END Std_orogen_typekits_mtype_std_vector_base_Wrench_Buffer;

DATA IMPLEMENTATION Std_orogen_typekits_mtype_std_vector_base_Wrench_Buffer.impl
    -- Buffer to hold a marshalled data of type Std_orogen_typekits_mtype_std_vector_base_Wrench
SUBCOMPONENTS
    Buffer : data Std_orogen_typekits_mtype_std_vector_base_Wrench_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Std_orogen_typekits_mtype_std_vector_base_Wrench_Buffer.impl;

DATA Base_samples_BodyState
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 1116; suggested aligned message buffer is...
    Source_Data_Size => 1120 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-BodyState";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_BodyState;

DATA IMPLEMENTATION Base_samples_BodyState.impl
END Base_samples_BodyState.impl;

DATA Base_samples_BodyState_Buffer_Max
END Base_samples_BodyState_Buffer_Max;

DATA IMPLEMENTATION Base_samples_BodyState_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_BodyState
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (1120); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_BodyState_Buffer_Max.impl;

DATA Base_samples_BodyState_Buffer
END Base_samples_BodyState_Buffer;

DATA IMPLEMENTATION Base_samples_BodyState_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_BodyState
SUBCOMPONENTS
    Buffer : data Base_samples_BodyState_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_BodyState_Buffer.impl;

DATA T_UInt64
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/taste-extended.asn");
    Ada_Package_Name => "TASTE_ExtendedTypes";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 8; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "T-UInt64";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aINTEGER;
END T_UInt64;

DATA IMPLEMENTATION T_UInt64.impl
END T_UInt64.impl;

DATA T_UInt64_Buffer_Max
END T_UInt64_Buffer_Max;

DATA IMPLEMENTATION T_UInt64_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type T_UInt64
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END T_UInt64_Buffer_Max.impl;

DATA T_UInt64_Buffer
END T_UInt64_Buffer;

DATA IMPLEMENTATION T_UInt64_Buffer.impl
    -- Buffer to hold a marshalled data of type T_UInt64
SUBCOMPONENTS
    Buffer : data T_UInt64_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END T_UInt64_Buffer.impl;

DATA DummyBase_T
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/userdefs-base.asn");
    Ada_Package_Name => "UserDefs_Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 8; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "DummyBase-T";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aINTEGER;
END DummyBase_T;

DATA IMPLEMENTATION DummyBase_T.impl
END DummyBase_T.impl;

DATA DummyBase_T_Buffer_Max
END DummyBase_T_Buffer_Max;

DATA IMPLEMENTATION DummyBase_T_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type DummyBase_T
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END DummyBase_T_Buffer_Max.impl;

DATA DummyBase_T_Buffer
END DummyBase_T_Buffer;

DATA IMPLEMENTATION DummyBase_T_Buffer.impl
    -- Buffer to hold a marshalled data of type DummyBase_T
SUBCOMPONENTS
    Buffer : data DummyBase_T_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END DummyBase_T_Buffer.impl;

DATA T_Int64
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/taste-extended.asn");
    Ada_Package_Name => "TASTE_ExtendedTypes";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 8; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "T-Int64";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aINTEGER;
END T_Int64;

DATA IMPLEMENTATION T_Int64.impl
END T_Int64.impl;

DATA T_Int64_Buffer_Max
END T_Int64_Buffer_Max;

DATA IMPLEMENTATION T_Int64_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type T_Int64
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END T_Int64_Buffer_Max.impl;

DATA T_Int64_Buffer
END T_Int64_Buffer;

DATA IMPLEMENTATION T_Int64_Buffer.impl
    -- Buffer to hold a marshalled data of type T_Int64
SUBCOMPONENTS
    Buffer : data T_Int64_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END T_Int64_Buffer.impl;

DATA Wrappers_Matrix4d
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 209; suggested aligned message buffer is...
    Source_Data_Size => 216 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Wrappers-Matrix4d";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Wrappers_Matrix4d;

DATA IMPLEMENTATION Wrappers_Matrix4d.impl
END Wrappers_Matrix4d.impl;

DATA Wrappers_Matrix4d_Buffer_Max
END Wrappers_Matrix4d_Buffer_Max;

DATA IMPLEMENTATION Wrappers_Matrix4d_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Wrappers_Matrix4d
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (216); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Wrappers_Matrix4d_Buffer_Max.impl;

DATA Wrappers_Matrix4d_Buffer
END Wrappers_Matrix4d_Buffer;

DATA IMPLEMENTATION Wrappers_Matrix4d_Buffer.impl
    -- Buffer to hold a marshalled data of type Wrappers_Matrix4d
SUBCOMPONENTS
    Buffer : data Wrappers_Matrix4d_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Wrappers_Matrix4d_Buffer.impl;

DATA Std_orogen_typekits_mtype_std_vector_base_JointTransform
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 88251; suggested aligned message buffer is...
    Source_Data_Size => 88256 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Std-orogen-typekits-mtype-std-vector-base-JointTransform";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCEOF;
END Std_orogen_typekits_mtype_std_vector_base_JointTransform;

DATA IMPLEMENTATION Std_orogen_typekits_mtype_std_vector_base_JointTransform.impl
END Std_orogen_typekits_mtype_std_vector_base_JointTransform.impl;

DATA Std_orogen_typekits_mtype_std_vector_base_JointTransform_Buffer_Max
END Std_orogen_typekits_mtype_std_vector_base_JointTransform_Buffer_Max;

DATA IMPLEMENTATION Std_orogen_typekits_mtype_std_vector_base_JointTransform_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Std_orogen_typekits_mtype_std_vector_base_JointTransform
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (88256); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Std_orogen_typekits_mtype_std_vector_base_JointTransform_Buffer_Max.impl;

DATA Std_orogen_typekits_mtype_std_vector_base_JointTransform_Buffer
END Std_orogen_typekits_mtype_std_vector_base_JointTransform_Buffer;

DATA IMPLEMENTATION Std_orogen_typekits_mtype_std_vector_base_JointTransform_Buffer.impl
    -- Buffer to hold a marshalled data of type Std_orogen_typekits_mtype_std_vector_base_JointTransform
SUBCOMPONENTS
    Buffer : data Std_orogen_typekits_mtype_std_vector_base_JointTransform_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Std_orogen_typekits_mtype_std_vector_base_JointTransform_Buffer.impl;

DATA Base_PoseUpdateThreshold
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 26; suggested aligned message buffer is...
    Source_Data_Size => 32 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-PoseUpdateThreshold";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_PoseUpdateThreshold;

DATA IMPLEMENTATION Base_PoseUpdateThreshold.impl
END Base_PoseUpdateThreshold.impl;

DATA Base_PoseUpdateThreshold_Buffer_Max
END Base_PoseUpdateThreshold_Buffer_Max;

DATA IMPLEMENTATION Base_PoseUpdateThreshold_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_PoseUpdateThreshold
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (32); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_PoseUpdateThreshold_Buffer_Max.impl;

DATA Base_PoseUpdateThreshold_Buffer
END Base_PoseUpdateThreshold_Buffer;

DATA IMPLEMENTATION Base_PoseUpdateThreshold_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_PoseUpdateThreshold
SUBCOMPONENTS
    Buffer : data Base_PoseUpdateThreshold_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_PoseUpdateThreshold_Buffer.impl;

DATA Base_NamedVector_Base_JointLimitRange
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 66202; suggested aligned message buffer is...
    Source_Data_Size => 66208 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-NamedVector-Base-JointLimitRange";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_NamedVector_Base_JointLimitRange;

DATA IMPLEMENTATION Base_NamedVector_Base_JointLimitRange.impl
END Base_NamedVector_Base_JointLimitRange.impl;

DATA Base_NamedVector_Base_JointLimitRange_Buffer_Max
END Base_NamedVector_Base_JointLimitRange_Buffer_Max;

DATA IMPLEMENTATION Base_NamedVector_Base_JointLimitRange_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_NamedVector_Base_JointLimitRange
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (66208); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_NamedVector_Base_JointLimitRange_Buffer_Max.impl;

DATA Base_NamedVector_Base_JointLimitRange_Buffer
END Base_NamedVector_Base_JointLimitRange_Buffer;

DATA IMPLEMENTATION Base_NamedVector_Base_JointLimitRange_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_NamedVector_Base_JointLimitRange
SUBCOMPONENTS
    Buffer : data Base_NamedVector_Base_JointLimitRange_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_NamedVector_Base_JointLimitRange_Buffer.impl;

DATA Base_Trajectory
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 5237; suggested aligned message buffer is...
    Source_Data_Size => 5240 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-Trajectory";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_Trajectory;

DATA IMPLEMENTATION Base_Trajectory.impl
END Base_Trajectory.impl;

DATA Base_Trajectory_Buffer_Max
END Base_Trajectory_Buffer_Max;

DATA IMPLEMENTATION Base_Trajectory_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_Trajectory
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (5240); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_Trajectory_Buffer_Max.impl;

DATA Base_Trajectory_Buffer
END Base_Trajectory_Buffer;

DATA IMPLEMENTATION Base_Trajectory_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_Trajectory
SUBCOMPONENTS
    Buffer : data Base_Trajectory_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_Trajectory_Buffer.impl;

DATA Base_NamedVector_Base_JointTrajectory
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 2640402; suggested aligned message buffer is...
    Source_Data_Size => 2640408 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-NamedVector-Base-JointTrajectory";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_NamedVector_Base_JointTrajectory;

DATA IMPLEMENTATION Base_NamedVector_Base_JointTrajectory.impl
END Base_NamedVector_Base_JointTrajectory.impl;

DATA Base_NamedVector_Base_JointTrajectory_Buffer_Max
END Base_NamedVector_Base_JointTrajectory_Buffer_Max;

DATA IMPLEMENTATION Base_NamedVector_Base_JointTrajectory_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_NamedVector_Base_JointTrajectory
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (2640408); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_NamedVector_Base_JointTrajectory_Buffer_Max.impl;

DATA Base_NamedVector_Base_JointTrajectory_Buffer
END Base_NamedVector_Base_JointTrajectory_Buffer;

DATA IMPLEMENTATION Base_NamedVector_Base_JointTrajectory_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_NamedVector_Base_JointTrajectory
SUBCOMPONENTS
    Buffer : data Base_NamedVector_Base_JointTrajectory_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_NamedVector_Base_JointTrajectory_Buffer.impl;

DATA Base_JointTransform
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 442; suggested aligned message buffer is...
    Source_Data_Size => 448 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-JointTransform";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_JointTransform;

DATA IMPLEMENTATION Base_JointTransform.impl
END Base_JointTransform.impl;

DATA Base_JointTransform_Buffer_Max
END Base_JointTransform_Buffer_Max;

DATA IMPLEMENTATION Base_JointTransform_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_JointTransform
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (448); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_JointTransform_Buffer_Max.impl;

DATA Base_JointTransform_Buffer
END Base_JointTransform_Buffer;

DATA IMPLEMENTATION Base_JointTransform_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_JointTransform
SUBCOMPONENTS
    Buffer : data Base_JointTransform_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_JointTransform_Buffer.impl;

DATA Std_orogen_typekits_mtype_std_vector_base_Waypoint
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 15651; suggested aligned message buffer is...
    Source_Data_Size => 15656 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Std-orogen-typekits-mtype-std-vector-base-Waypoint";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCEOF;
END Std_orogen_typekits_mtype_std_vector_base_Waypoint;

DATA IMPLEMENTATION Std_orogen_typekits_mtype_std_vector_base_Waypoint.impl
END Std_orogen_typekits_mtype_std_vector_base_Waypoint.impl;

DATA Std_orogen_typekits_mtype_std_vector_base_Waypoint_Buffer_Max
END Std_orogen_typekits_mtype_std_vector_base_Waypoint_Buffer_Max;

DATA IMPLEMENTATION Std_orogen_typekits_mtype_std_vector_base_Waypoint_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Std_orogen_typekits_mtype_std_vector_base_Waypoint
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (15656); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Std_orogen_typekits_mtype_std_vector_base_Waypoint_Buffer_Max.impl;

DATA Std_orogen_typekits_mtype_std_vector_base_Waypoint_Buffer
END Std_orogen_typekits_mtype_std_vector_base_Waypoint_Buffer;

DATA IMPLEMENTATION Std_orogen_typekits_mtype_std_vector_base_Waypoint_Buffer.impl
    -- Buffer to hold a marshalled data of type Std_orogen_typekits_mtype_std_vector_base_Waypoint
SUBCOMPONENTS
    Buffer : data Std_orogen_typekits_mtype_std_vector_base_Waypoint_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Std_orogen_typekits_mtype_std_vector_base_Waypoint_Buffer.impl;

DATA Base_samples_DepthMap
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 12022; suggested aligned message buffer is...
    Source_Data_Size => 12024 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-DepthMap";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_DepthMap;

DATA IMPLEMENTATION Base_samples_DepthMap.impl
END Base_samples_DepthMap.impl;

DATA Base_samples_DepthMap_Buffer_Max
END Base_samples_DepthMap_Buffer_Max;

DATA IMPLEMENTATION Base_samples_DepthMap_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_DepthMap
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (12024); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_DepthMap_Buffer_Max.impl;

DATA Base_samples_DepthMap_Buffer
END Base_samples_DepthMap_Buffer;

DATA IMPLEMENTATION Base_samples_DepthMap_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_DepthMap
SUBCOMPONENTS
    Buffer : data Base_samples_DepthMap_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_DepthMap_Buffer.impl;

DATA T_Int8
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/taste-types.asn");
    Ada_Package_Name => "TASTE_BasicTypes";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 8; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "T-Int8";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aINTEGER;
END T_Int8;

DATA IMPLEMENTATION T_Int8.impl
END T_Int8.impl;

DATA T_Int8_Buffer_Max
END T_Int8_Buffer_Max;

DATA IMPLEMENTATION T_Int8_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type T_Int8
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END T_Int8_Buffer_Max.impl;

DATA T_Int8_Buffer
END T_Int8_Buffer;

DATA IMPLEMENTATION T_Int8_Buffer.impl
    -- Buffer to hold a marshalled data of type T_Int8
SUBCOMPONENTS
    Buffer : data T_Int8_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END T_Int8_Buffer.impl;

DATA Base_samples_DepthMap_PROJECTION_TYPE
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 4; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-DepthMap-PROJECTION-TYPE";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aENUMERATED;
END Base_samples_DepthMap_PROJECTION_TYPE;

DATA IMPLEMENTATION Base_samples_DepthMap_PROJECTION_TYPE.impl
END Base_samples_DepthMap_PROJECTION_TYPE.impl;

DATA Base_samples_DepthMap_PROJECTION_TYPE_Buffer_Max
END Base_samples_DepthMap_PROJECTION_TYPE_Buffer_Max;

DATA IMPLEMENTATION Base_samples_DepthMap_PROJECTION_TYPE_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_DepthMap_PROJECTION_TYPE
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_DepthMap_PROJECTION_TYPE_Buffer_Max.impl;

DATA Base_samples_DepthMap_PROJECTION_TYPE_Buffer
END Base_samples_DepthMap_PROJECTION_TYPE_Buffer;

DATA IMPLEMENTATION Base_samples_DepthMap_PROJECTION_TYPE_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_DepthMap_PROJECTION_TYPE
SUBCOMPONENTS
    Buffer : data Base_samples_DepthMap_PROJECTION_TYPE_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_DepthMap_PROJECTION_TYPE_Buffer.impl;

DATA Base_samples_Pointcloud
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 18310; suggested aligned message buffer is...
    Source_Data_Size => 18312 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-Pointcloud";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_Pointcloud;

DATA IMPLEMENTATION Base_samples_Pointcloud.impl
END Base_samples_Pointcloud.impl;

DATA Base_samples_Pointcloud_Buffer_Max
END Base_samples_Pointcloud_Buffer_Max;

DATA IMPLEMENTATION Base_samples_Pointcloud_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_Pointcloud
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (18312); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_Pointcloud_Buffer_Max.impl;

DATA Base_samples_Pointcloud_Buffer
END Base_samples_Pointcloud_Buffer;

DATA IMPLEMENTATION Base_samples_Pointcloud_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_Pointcloud
SUBCOMPONENTS
    Buffer : data Base_samples_Pointcloud_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_Pointcloud_Buffer.impl;

DATA Base_Pressure
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 13; suggested aligned message buffer is...
    Source_Data_Size => 16 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-Pressure";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_Pressure;

DATA IMPLEMENTATION Base_Pressure.impl
END Base_Pressure.impl;

DATA Base_Pressure_Buffer_Max
END Base_Pressure_Buffer_Max;

DATA IMPLEMENTATION Base_Pressure_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_Pressure
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (16); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_Pressure_Buffer_Max.impl;

DATA Base_Pressure_Buffer
END Base_Pressure_Buffer;

DATA IMPLEMENTATION Base_Pressure_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_Pressure
SUBCOMPONENTS
    Buffer : data Base_Pressure_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_Pressure_Buffer.impl;

DATA Base_samples_Pressure
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 21; suggested aligned message buffer is...
    Source_Data_Size => 24 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-Pressure";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_Pressure;

DATA IMPLEMENTATION Base_samples_Pressure.impl
END Base_samples_Pressure.impl;

DATA Base_samples_Pressure_Buffer_Max
END Base_samples_Pressure_Buffer_Max;

DATA IMPLEMENTATION Base_samples_Pressure_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_Pressure
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (24); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_Pressure_Buffer_Max.impl;

DATA Base_samples_Pressure_Buffer
END Base_samples_Pressure_Buffer;

DATA IMPLEMENTATION Base_samples_Pressure_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_Pressure
SUBCOMPONENTS
    Buffer : data Base_samples_Pressure_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_Pressure_Buffer.impl;

DATA Wrappers_Quaterniond
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 53; suggested aligned message buffer is...
    Source_Data_Size => 56 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Wrappers-Quaterniond";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Wrappers_Quaterniond;

DATA IMPLEMENTATION Wrappers_Quaterniond.impl
END Wrappers_Quaterniond.impl;

DATA Wrappers_Quaterniond_Buffer_Max
END Wrappers_Quaterniond_Buffer_Max;

DATA IMPLEMENTATION Wrappers_Quaterniond_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Wrappers_Quaterniond
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (56); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Wrappers_Quaterniond_Buffer_Max.impl;

DATA Wrappers_Quaterniond_Buffer
END Wrappers_Quaterniond_Buffer;

DATA IMPLEMENTATION Wrappers_Quaterniond_Buffer.impl
    -- Buffer to hold a marshalled data of type Wrappers_Quaterniond
SUBCOMPONENTS
    Buffer : data Wrappers_Quaterniond_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Wrappers_Quaterniond_Buffer.impl;

DATA Base_samples_frame_frame_attrib_t
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 408; suggested aligned message buffer is...
    Source_Data_Size => 408 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-frame-frame-attrib-t";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_frame_frame_attrib_t;

DATA IMPLEMENTATION Base_samples_frame_frame_attrib_t.impl
END Base_samples_frame_frame_attrib_t.impl;

DATA Base_samples_frame_frame_attrib_t_Buffer_Max
END Base_samples_frame_frame_attrib_t_Buffer_Max;

DATA IMPLEMENTATION Base_samples_frame_frame_attrib_t_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_frame_frame_attrib_t
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (408); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_frame_frame_attrib_t_Buffer_Max.impl;

DATA Base_samples_frame_frame_attrib_t_Buffer
END Base_samples_frame_frame_attrib_t_Buffer;

DATA IMPLEMENTATION Base_samples_frame_frame_attrib_t_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_frame_frame_attrib_t
SUBCOMPONENTS
    Buffer : data Base_samples_frame_frame_attrib_t_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_frame_frame_attrib_t_Buffer.impl;

DATA Std_orogen_typekits_mtype_std_vector_base_Trajectory
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 1047276; suggested aligned message buffer is...
    Source_Data_Size => 1047280 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Std-orogen-typekits-mtype-std-vector-base-Trajectory";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCEOF;
END Std_orogen_typekits_mtype_std_vector_base_Trajectory;

DATA IMPLEMENTATION Std_orogen_typekits_mtype_std_vector_base_Trajectory.impl
END Std_orogen_typekits_mtype_std_vector_base_Trajectory.impl;

DATA Std_orogen_typekits_mtype_std_vector_base_Trajectory_Buffer_Max
END Std_orogen_typekits_mtype_std_vector_base_Trajectory_Buffer_Max;

DATA IMPLEMENTATION Std_orogen_typekits_mtype_std_vector_base_Trajectory_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Std_orogen_typekits_mtype_std_vector_base_Trajectory
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (1047280); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Std_orogen_typekits_mtype_std_vector_base_Trajectory_Buffer_Max.impl;

DATA Std_orogen_typekits_mtype_std_vector_base_Trajectory_Buffer
END Std_orogen_typekits_mtype_std_vector_base_Trajectory_Buffer;

DATA IMPLEMENTATION Std_orogen_typekits_mtype_std_vector_base_Trajectory_Buffer.impl
    -- Buffer to hold a marshalled data of type Std_orogen_typekits_mtype_std_vector_base_Trajectory
SUBCOMPONENTS
    Buffer : data Std_orogen_typekits_mtype_std_vector_base_Trajectory_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Std_orogen_typekits_mtype_std_vector_base_Trajectory_Buffer.impl;

DATA Base_Time_Resolution
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 4; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-Time-Resolution";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aENUMERATED;
END Base_Time_Resolution;

DATA IMPLEMENTATION Base_Time_Resolution.impl
END Base_Time_Resolution.impl;

DATA Base_Time_Resolution_Buffer_Max
END Base_Time_Resolution_Buffer_Max;

DATA IMPLEMENTATION Base_Time_Resolution_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_Time_Resolution
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_Time_Resolution_Buffer_Max.impl;

DATA Base_Time_Resolution_Buffer
END Base_Time_Resolution_Buffer;

DATA IMPLEMENTATION Base_Time_Resolution_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_Time_Resolution
SUBCOMPONENTS
    Buffer : data Base_Time_Resolution_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_Time_Resolution_Buffer.impl;

DATA Base_NamedVector_base_Wrench_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 55902; suggested aligned message buffer is...
    Source_Data_Size => 55904 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-NamedVector-base-Wrench-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_NamedVector_base_Wrench_m;

DATA IMPLEMENTATION Base_NamedVector_base_Wrench_m.impl
END Base_NamedVector_base_Wrench_m.impl;

DATA Base_NamedVector_base_Wrench_m_Buffer_Max
END Base_NamedVector_base_Wrench_m_Buffer_Max;

DATA IMPLEMENTATION Base_NamedVector_base_Wrench_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_NamedVector_base_Wrench_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (55904); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_NamedVector_base_Wrench_m_Buffer_Max.impl;

DATA Base_NamedVector_base_Wrench_m_Buffer
END Base_NamedVector_base_Wrench_m_Buffer;

DATA IMPLEMENTATION Base_NamedVector_base_Wrench_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_NamedVector_base_Wrench_m
SUBCOMPONENTS
    Buffer : data Base_NamedVector_base_Wrench_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_NamedVector_base_Wrench_m_Buffer.impl;

DATA Base_samples_LaserScan
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 3457; suggested aligned message buffer is...
    Source_Data_Size => 3464 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-LaserScan";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_LaserScan;

DATA IMPLEMENTATION Base_samples_LaserScan.impl
END Base_samples_LaserScan.impl;

DATA Base_samples_LaserScan_Buffer_Max
END Base_samples_LaserScan_Buffer_Max;

DATA IMPLEMENTATION Base_samples_LaserScan_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_LaserScan
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (3464); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_LaserScan_Buffer_Max.impl;

DATA Base_samples_LaserScan_Buffer
END Base_samples_LaserScan_Buffer;

DATA IMPLEMENTATION Base_samples_LaserScan_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_LaserScan
SUBCOMPONENTS
    Buffer : data Base_samples_LaserScan_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_LaserScan_Buffer.impl;

DATA T_Int16
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/taste-extended.asn");
    Ada_Package_Name => "TASTE_ExtendedTypes";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 8; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "T-Int16";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aINTEGER;
END T_Int16;

DATA IMPLEMENTATION T_Int16.impl
END T_Int16.impl;

DATA T_Int16_Buffer_Max
END T_Int16_Buffer_Max;

DATA IMPLEMENTATION T_Int16_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type T_Int16
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END T_Int16_Buffer_Max.impl;

DATA T_Int16_Buffer
END T_Int16_Buffer;

DATA IMPLEMENTATION T_Int16_Buffer.impl
    -- Buffer to hold a marshalled data of type T_Int16
SUBCOMPONENTS
    Buffer : data T_Int16_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END T_Int16_Buffer.impl;

DATA Base_samples_Wrenches_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 55910; suggested aligned message buffer is...
    Source_Data_Size => 55912 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-Wrenches-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_Wrenches_m;

DATA IMPLEMENTATION Base_samples_Wrenches_m.impl
END Base_samples_Wrenches_m.impl;

DATA Base_samples_Wrenches_m_Buffer_Max
END Base_samples_Wrenches_m_Buffer_Max;

DATA IMPLEMENTATION Base_samples_Wrenches_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_Wrenches_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (55912); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_Wrenches_m_Buffer_Max.impl;

DATA Base_samples_Wrenches_m_Buffer
END Base_samples_Wrenches_m_Buffer;

DATA IMPLEMENTATION Base_samples_Wrenches_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_Wrenches_m
SUBCOMPONENTS
    Buffer : data Base_samples_Wrenches_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_Wrenches_m_Buffer.impl;

DATA Base_samples_Sonar
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 6866; suggested aligned message buffer is...
    Source_Data_Size => 6872 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-Sonar";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_Sonar;

DATA IMPLEMENTATION Base_samples_Sonar.impl
END Base_samples_Sonar.impl;

DATA Base_samples_Sonar_Buffer_Max
END Base_samples_Sonar_Buffer_Max;

DATA IMPLEMENTATION Base_samples_Sonar_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_Sonar
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (6872); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_Sonar_Buffer_Max.impl;

DATA Base_samples_Sonar_Buffer
END Base_samples_Sonar_Buffer;

DATA IMPLEMENTATION Base_samples_Sonar_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_Sonar
SUBCOMPONENTS
    Buffer : data Base_samples_Sonar_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_Sonar_Buffer.impl;

DATA Base_samples_IMUSensors_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 126; suggested aligned message buffer is...
    Source_Data_Size => 128 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-IMUSensors-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_IMUSensors_m;

DATA IMPLEMENTATION Base_samples_IMUSensors_m.impl
END Base_samples_IMUSensors_m.impl;

DATA Base_samples_IMUSensors_m_Buffer_Max
END Base_samples_IMUSensors_m_Buffer_Max;

DATA IMPLEMENTATION Base_samples_IMUSensors_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_IMUSensors_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (128); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_IMUSensors_m_Buffer_Max.impl;

DATA Base_samples_IMUSensors_m_Buffer
END Base_samples_IMUSensors_m_Buffer;

DATA IMPLEMENTATION Base_samples_IMUSensors_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_IMUSensors_m
SUBCOMPONENTS
    Buffer : data Base_samples_IMUSensors_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_IMUSensors_m_Buffer.impl;

DATA Wrappers_Matrix2d
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 53; suggested aligned message buffer is...
    Source_Data_Size => 56 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Wrappers-Matrix2d";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Wrappers_Matrix2d;

DATA IMPLEMENTATION Wrappers_Matrix2d.impl
END Wrappers_Matrix2d.impl;

DATA Wrappers_Matrix2d_Buffer_Max
END Wrappers_Matrix2d_Buffer_Max;

DATA IMPLEMENTATION Wrappers_Matrix2d_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Wrappers_Matrix2d
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (56); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Wrappers_Matrix2d_Buffer_Max.impl;

DATA Wrappers_Matrix2d_Buffer
END Wrappers_Matrix2d_Buffer;

DATA IMPLEMENTATION Wrappers_Matrix2d_Buffer.impl
    -- Buffer to hold a marshalled data of type Wrappers_Matrix2d
SUBCOMPONENTS
    Buffer : data Wrappers_Matrix2d_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Wrappers_Matrix2d_Buffer.impl;

DATA Wrappers_Vector6d
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 79; suggested aligned message buffer is...
    Source_Data_Size => 80 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Wrappers-Vector6d";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Wrappers_Vector6d;

DATA IMPLEMENTATION Wrappers_Vector6d.impl
END Wrappers_Vector6d.impl;

DATA Wrappers_Vector6d_Buffer_Max
END Wrappers_Vector6d_Buffer_Max;

DATA IMPLEMENTATION Wrappers_Vector6d_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Wrappers_Vector6d
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (80); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Wrappers_Vector6d_Buffer_Max.impl;

DATA Wrappers_Vector6d_Buffer
END Wrappers_Vector6d_Buffer;

DATA IMPLEMENTATION Wrappers_Vector6d_Buffer.impl
    -- Buffer to hold a marshalled data of type Wrappers_Vector6d
SUBCOMPONENTS
    Buffer : data Wrappers_Vector6d_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Wrappers_Vector6d_Buffer.impl;

DATA Base_JointLimits
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 66202; suggested aligned message buffer is...
    Source_Data_Size => 66208 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-JointLimits";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_JointLimits;

DATA IMPLEMENTATION Base_JointLimits.impl
END Base_JointLimits.impl;

DATA Base_JointLimits_Buffer_Max
END Base_JointLimits_Buffer_Max;

DATA IMPLEMENTATION Base_JointLimits_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_JointLimits
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (66208); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_JointLimits_Buffer_Max.impl;

DATA Base_JointLimits_Buffer
END Base_JointLimits_Buffer;

DATA IMPLEMENTATION Base_JointLimits_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_JointLimits
SUBCOMPONENTS
    Buffer : data Base_JointLimits_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_JointLimits_Buffer.impl;

DATA Base_samples_Motion2D
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 47; suggested aligned message buffer is...
    Source_Data_Size => 48 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-Motion2D";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_Motion2D;

DATA IMPLEMENTATION Base_samples_Motion2D.impl
END Base_samples_Motion2D.impl;

DATA Base_samples_Motion2D_Buffer_Max
END Base_samples_Motion2D_Buffer_Max;

DATA IMPLEMENTATION Base_samples_Motion2D_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_Motion2D
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (48); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_Motion2D_Buffer_Max.impl;

DATA Base_samples_Motion2D_Buffer
END Base_samples_Motion2D_Buffer;

DATA IMPLEMENTATION Base_samples_Motion2D_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_Motion2D
SUBCOMPONENTS
    Buffer : data Base_samples_Motion2D_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_Motion2D_Buffer.impl;

DATA Base_samples_Wrench_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 87; suggested aligned message buffer is...
    Source_Data_Size => 88 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-Wrench-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_Wrench_m;

DATA IMPLEMENTATION Base_samples_Wrench_m.impl
END Base_samples_Wrench_m.impl;

DATA Base_samples_Wrench_m_Buffer_Max
END Base_samples_Wrench_m_Buffer_Max;

DATA IMPLEMENTATION Base_samples_Wrench_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_Wrench_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (88); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_Wrench_m_Buffer_Max.impl;

DATA Base_samples_Wrench_m_Buffer
END Base_samples_Wrench_m_Buffer;

DATA IMPLEMENTATION Base_samples_Wrench_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_Wrench_m
SUBCOMPONENTS
    Buffer : data Base_samples_Wrench_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_Wrench_m_Buffer.impl;

DATA Base_JointState
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 65; suggested aligned message buffer is...
    Source_Data_Size => 72 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-JointState";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_JointState;

DATA IMPLEMENTATION Base_JointState.impl
END Base_JointState.impl;

DATA Base_JointState_Buffer_Max
END Base_JointState_Buffer_Max;

DATA IMPLEMENTATION Base_JointState_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_JointState
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (72); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_JointState_Buffer_Max.impl;

DATA Base_JointState_Buffer
END Base_JointState_Buffer;

DATA IMPLEMENTATION Base_JointState_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_JointState
SUBCOMPONENTS
    Buffer : data Base_JointState_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_JointState_Buffer.impl;

DATA Base_TransformWithCovariance
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 561; suggested aligned message buffer is...
    Source_Data_Size => 568 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-TransformWithCovariance";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_TransformWithCovariance;

DATA IMPLEMENTATION Base_TransformWithCovariance.impl
END Base_TransformWithCovariance.impl;

DATA Base_TransformWithCovariance_Buffer_Max
END Base_TransformWithCovariance_Buffer_Max;

DATA IMPLEMENTATION Base_TransformWithCovariance_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_TransformWithCovariance
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (568); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_TransformWithCovariance_Buffer_Max.impl;

DATA Base_TransformWithCovariance_Buffer
END Base_TransformWithCovariance_Buffer;

DATA IMPLEMENTATION Base_TransformWithCovariance_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_TransformWithCovariance
SUBCOMPONENTS
    Buffer : data Base_TransformWithCovariance_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_TransformWithCovariance_Buffer.impl;

DATA Base_commands_Speed6D
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 78; suggested aligned message buffer is...
    Source_Data_Size => 80 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-commands-Speed6D";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_commands_Speed6D;

DATA IMPLEMENTATION Base_commands_Speed6D.impl
END Base_commands_Speed6D.impl;

DATA Base_commands_Speed6D_Buffer_Max
END Base_commands_Speed6D_Buffer_Max;

DATA IMPLEMENTATION Base_commands_Speed6D_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_commands_Speed6D
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (80); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_commands_Speed6D_Buffer_Max.impl;

DATA Base_commands_Speed6D_Buffer
END Base_commands_Speed6D_Buffer;

DATA IMPLEMENTATION Base_commands_Speed6D_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_commands_Speed6D
SUBCOMPONENTS
    Buffer : data Base_commands_Speed6D_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_commands_Speed6D_Buffer.impl;

DATA Wrappers_MatrixXd
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 2609; suggested aligned message buffer is...
    Source_Data_Size => 2616 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Wrappers-MatrixXd";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Wrappers_MatrixXd;

DATA IMPLEMENTATION Wrappers_MatrixXd.impl
END Wrappers_MatrixXd.impl;

DATA Wrappers_MatrixXd_Buffer_Max
END Wrappers_MatrixXd_Buffer_Max;

DATA IMPLEMENTATION Wrappers_MatrixXd_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Wrappers_MatrixXd
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (2616); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Wrappers_MatrixXd_Buffer_Max.impl;

DATA Wrappers_MatrixXd_Buffer
END Wrappers_MatrixXd_Buffer;

DATA IMPLEMENTATION Wrappers_MatrixXd_Buffer.impl
    -- Buffer to hold a marshalled data of type Wrappers_MatrixXd
SUBCOMPONENTS
    Buffer : data Wrappers_MatrixXd_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Wrappers_MatrixXd_Buffer.impl;

DATA T_UInt8
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/taste-types.asn");
    Ada_Package_Name => "TASTE_BasicTypes";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 8; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "T-UInt8";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aINTEGER;
END T_UInt8;

DATA IMPLEMENTATION T_UInt8.impl
END T_UInt8.impl;

DATA T_UInt8_Buffer_Max
END T_UInt8_Buffer_Max;

DATA IMPLEMENTATION T_UInt8_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type T_UInt8
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END T_UInt8_Buffer_Max.impl;

DATA T_UInt8_Buffer
END T_UInt8_Buffer;

DATA IMPLEMENTATION T_UInt8_Buffer.impl
    -- Buffer to hold a marshalled data of type T_UInt8
SUBCOMPONENTS
    Buffer : data T_UInt8_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END T_UInt8_Buffer.impl;

DATA Base_samples_frame_frame_mode_t
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 4; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-frame-frame-mode-t";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aENUMERATED;
END Base_samples_frame_frame_mode_t;

DATA IMPLEMENTATION Base_samples_frame_frame_mode_t.impl
END Base_samples_frame_frame_mode_t.impl;

DATA Base_samples_frame_frame_mode_t_Buffer_Max
END Base_samples_frame_frame_mode_t_Buffer_Max;

DATA IMPLEMENTATION Base_samples_frame_frame_mode_t_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_frame_frame_mode_t
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_frame_frame_mode_t_Buffer_Max.impl;

DATA Base_samples_frame_frame_mode_t_Buffer
END Base_samples_frame_frame_mode_t_Buffer;

DATA IMPLEMENTATION Base_samples_frame_frame_mode_t_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_frame_frame_mode_t
SUBCOMPONENTS
    Buffer : data Base_samples_frame_frame_mode_t_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_frame_frame_mode_t_Buffer.impl;

DATA Base_LinearAngular6DCommand
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 87; suggested aligned message buffer is...
    Source_Data_Size => 88 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-LinearAngular6DCommand";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_LinearAngular6DCommand;

DATA IMPLEMENTATION Base_LinearAngular6DCommand.impl
END Base_LinearAngular6DCommand.impl;

DATA Base_LinearAngular6DCommand_Buffer_Max
END Base_LinearAngular6DCommand_Buffer_Max;

DATA IMPLEMENTATION Base_LinearAngular6DCommand_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_LinearAngular6DCommand
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (88); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_LinearAngular6DCommand_Buffer_Max.impl;

DATA Base_LinearAngular6DCommand_Buffer
END Base_LinearAngular6DCommand_Buffer;

DATA IMPLEMENTATION Base_LinearAngular6DCommand_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_LinearAngular6DCommand
SUBCOMPONENTS
    Buffer : data Base_LinearAngular6DCommand_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_LinearAngular6DCommand_Buffer.impl;

DATA Base_commands_Joints
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 53210; suggested aligned message buffer is...
    Source_Data_Size => 53216 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-commands-Joints";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_commands_Joints;

DATA IMPLEMENTATION Base_commands_Joints.impl
END Base_commands_Joints.impl;

DATA Base_commands_Joints_Buffer_Max
END Base_commands_Joints_Buffer_Max;

DATA IMPLEMENTATION Base_commands_Joints_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_commands_Joints
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (53216); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_commands_Joints_Buffer_Max.impl;

DATA Base_commands_Joints_Buffer
END Base_commands_Joints_Buffer;

DATA IMPLEMENTATION Base_commands_Joints_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_commands_Joints
SUBCOMPONENTS
    Buffer : data Base_commands_Joints_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_commands_Joints_Buffer.impl;

DATA Wrappers_geometry_Spline
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 5224; suggested aligned message buffer is...
    Source_Data_Size => 5224 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Wrappers-geometry-Spline";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Wrappers_geometry_Spline;

DATA IMPLEMENTATION Wrappers_geometry_Spline.impl
END Wrappers_geometry_Spline.impl;

DATA Wrappers_geometry_Spline_Buffer_Max
END Wrappers_geometry_Spline_Buffer_Max;

DATA IMPLEMENTATION Wrappers_geometry_Spline_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Wrappers_geometry_Spline
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (5224); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Wrappers_geometry_Spline_Buffer_Max.impl;

DATA Wrappers_geometry_Spline_Buffer
END Wrappers_geometry_Spline_Buffer;

DATA IMPLEMENTATION Wrappers_geometry_Spline_Buffer.impl
    -- Buffer to hold a marshalled data of type Wrappers_geometry_Spline
SUBCOMPONENTS
    Buffer : data Wrappers_geometry_Spline_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Wrappers_geometry_Spline_Buffer.impl;

DATA Base_commands_Motion2D
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 39; suggested aligned message buffer is...
    Source_Data_Size => 40 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-commands-Motion2D";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_commands_Motion2D;

DATA IMPLEMENTATION Base_commands_Motion2D.impl
END Base_commands_Motion2D.impl;

DATA Base_commands_Motion2D_Buffer_Max
END Base_commands_Motion2D_Buffer_Max;

DATA IMPLEMENTATION Base_commands_Motion2D_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_commands_Motion2D
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (40); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_commands_Motion2D_Buffer_Max.impl;

DATA Base_commands_Motion2D_Buffer
END Base_commands_Motion2D_Buffer;

DATA IMPLEMENTATION Base_commands_Motion2D_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_commands_Motion2D
SUBCOMPONENTS
    Buffer : data Base_commands_Motion2D_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_commands_Motion2D_Buffer.impl;

DATA Base_samples_frame_frame_status_t
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 4; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-frame-frame-status-t";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aENUMERATED;
END Base_samples_frame_frame_status_t;

DATA IMPLEMENTATION Base_samples_frame_frame_status_t.impl
END Base_samples_frame_frame_status_t.impl;

DATA Base_samples_frame_frame_status_t_Buffer_Max
END Base_samples_frame_frame_status_t_Buffer_Max;

DATA IMPLEMENTATION Base_samples_frame_frame_status_t_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_frame_frame_status_t
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_frame_frame_status_t_Buffer_Max.impl;

DATA Base_samples_frame_frame_status_t_Buffer
END Base_samples_frame_frame_status_t_Buffer;

DATA IMPLEMENTATION Base_samples_frame_frame_status_t_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_frame_frame_status_t
SUBCOMPONENTS
    Buffer : data Base_samples_frame_frame_status_t_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_frame_frame_status_t_Buffer.impl;

DATA Wrappers_Vector4d
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 53; suggested aligned message buffer is...
    Source_Data_Size => 56 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Wrappers-Vector4d";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Wrappers_Vector4d;

DATA IMPLEMENTATION Wrappers_Vector4d.impl
END Wrappers_Vector4d.impl;

DATA Wrappers_Vector4d_Buffer_Max
END Wrappers_Vector4d_Buffer_Max;

DATA IMPLEMENTATION Wrappers_Vector4d_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Wrappers_Vector4d
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (56); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Wrappers_Vector4d_Buffer_Max.impl;

DATA Wrappers_Vector4d_Buffer
END Wrappers_Vector4d_Buffer;

DATA IMPLEMENTATION Wrappers_Vector4d_Buffer.impl
    -- Buffer to hold a marshalled data of type Wrappers_Vector4d
SUBCOMPONENTS
    Buffer : data Wrappers_Vector4d_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Wrappers_Vector4d_Buffer.impl;

DATA Base_samples_RigidBodyAcceleration_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 322; suggested aligned message buffer is...
    Source_Data_Size => 328 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-RigidBodyAcceleration-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_RigidBodyAcceleration_m;

DATA IMPLEMENTATION Base_samples_RigidBodyAcceleration_m.impl
END Base_samples_RigidBodyAcceleration_m.impl;

DATA Base_samples_RigidBodyAcceleration_m_Buffer_Max
END Base_samples_RigidBodyAcceleration_m_Buffer_Max;

DATA IMPLEMENTATION Base_samples_RigidBodyAcceleration_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_RigidBodyAcceleration_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (328); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_RigidBodyAcceleration_m_Buffer_Max.impl;

DATA Base_samples_RigidBodyAcceleration_m_Buffer
END Base_samples_RigidBodyAcceleration_m_Buffer;

DATA IMPLEMENTATION Base_samples_RigidBodyAcceleration_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_RigidBodyAcceleration_m
SUBCOMPONENTS
    Buffer : data Base_samples_RigidBodyAcceleration_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_RigidBodyAcceleration_m_Buffer.impl;

DATA Base_JointsTrajectory
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 2642003; suggested aligned message buffer is...
    Source_Data_Size => 2642008 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-JointsTrajectory";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_JointsTrajectory;

DATA IMPLEMENTATION Base_JointsTrajectory.impl
END Base_JointsTrajectory.impl;

DATA Base_JointsTrajectory_Buffer_Max
END Base_JointsTrajectory_Buffer_Max;

DATA IMPLEMENTATION Base_JointsTrajectory_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_JointsTrajectory
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (2642008); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_JointsTrajectory_Buffer_Max.impl;

DATA Base_JointsTrajectory_Buffer
END Base_JointsTrajectory_Buffer;

DATA IMPLEMENTATION Base_JointsTrajectory_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_JointsTrajectory
SUBCOMPONENTS
    Buffer : data Base_JointsTrajectory_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_JointsTrajectory_Buffer.impl;

DATA Base_samples_Wrench
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 87; suggested aligned message buffer is...
    Source_Data_Size => 88 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-Wrench";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_Wrench;

DATA IMPLEMENTATION Base_samples_Wrench.impl
END Base_samples_Wrench.impl;

DATA Base_samples_Wrench_Buffer_Max
END Base_samples_Wrench_Buffer_Max;

DATA IMPLEMENTATION Base_samples_Wrench_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_Wrench
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (88); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_Wrench_Buffer_Max.impl;

DATA Base_samples_Wrench_Buffer
END Base_samples_Wrench_Buffer;

DATA IMPLEMENTATION Base_samples_Wrench_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_Wrench
SUBCOMPONENTS
    Buffer : data Base_samples_Wrench_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_Wrench_Buffer.impl;

DATA Wrappers_Matrix3d
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 118; suggested aligned message buffer is...
    Source_Data_Size => 120 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Wrappers-Matrix3d";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Wrappers_Matrix3d;

DATA IMPLEMENTATION Wrappers_Matrix3d.impl
END Wrappers_Matrix3d.impl;

DATA Wrappers_Matrix3d_Buffer_Max
END Wrappers_Matrix3d_Buffer_Max;

DATA IMPLEMENTATION Wrappers_Matrix3d_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Wrappers_Matrix3d
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (120); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Wrappers_Matrix3d_Buffer_Max.impl;

DATA Wrappers_Matrix3d_Buffer
END Wrappers_Matrix3d_Buffer;

DATA IMPLEMENTATION Wrappers_Matrix3d_Buffer.impl
    -- Buffer to hold a marshalled data of type Wrappers_Matrix3d
SUBCOMPONENTS
    Buffer : data Wrappers_Matrix3d_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Wrappers_Matrix3d_Buffer.impl;

DATA Std_vector_Wrappers_Vector4d
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 10451; suggested aligned message buffer is...
    Source_Data_Size => 10456 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Std-vector-Wrappers-Vector4d";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCEOF;
END Std_vector_Wrappers_Vector4d;

DATA IMPLEMENTATION Std_vector_Wrappers_Vector4d.impl
END Std_vector_Wrappers_Vector4d.impl;

DATA Std_vector_Wrappers_Vector4d_Buffer_Max
END Std_vector_Wrappers_Vector4d_Buffer_Max;

DATA IMPLEMENTATION Std_vector_Wrappers_Vector4d_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Std_vector_Wrappers_Vector4d
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (10456); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Std_vector_Wrappers_Vector4d_Buffer_Max.impl;

DATA Std_vector_Wrappers_Vector4d_Buffer
END Std_vector_Wrappers_Vector4d_Buffer;

DATA IMPLEMENTATION Std_vector_Wrappers_Vector4d_Buffer.impl
    -- Buffer to hold a marshalled data of type Std_vector_Wrappers_Vector4d
SUBCOMPONENTS
    Buffer : data Std_vector_Wrappers_Vector4d_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Std_vector_Wrappers_Vector4d_Buffer.impl;

DATA Base_TransformWithCovariance_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 561; suggested aligned message buffer is...
    Source_Data_Size => 568 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-TransformWithCovariance-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_TransformWithCovariance_m;

DATA IMPLEMENTATION Base_TransformWithCovariance_m.impl
END Base_TransformWithCovariance_m.impl;

DATA Base_TransformWithCovariance_m_Buffer_Max
END Base_TransformWithCovariance_m_Buffer_Max;

DATA IMPLEMENTATION Base_TransformWithCovariance_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_TransformWithCovariance_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (568); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_TransformWithCovariance_m_Buffer_Max.impl;

DATA Base_TransformWithCovariance_m_Buffer
END Base_TransformWithCovariance_m_Buffer;

DATA IMPLEMENTATION Base_TransformWithCovariance_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_TransformWithCovariance_m
SUBCOMPONENTS
    Buffer : data Base_TransformWithCovariance_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_TransformWithCovariance_m_Buffer.impl;

DATA Base_samples_RigidBodyState_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 1050; suggested aligned message buffer is...
    Source_Data_Size => 1056 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-RigidBodyState-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_RigidBodyState_m;

DATA IMPLEMENTATION Base_samples_RigidBodyState_m.impl
END Base_samples_RigidBodyState_m.impl;

DATA Base_samples_RigidBodyState_m_Buffer_Max
END Base_samples_RigidBodyState_m_Buffer_Max;

DATA IMPLEMENTATION Base_samples_RigidBodyState_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_RigidBodyState_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (1056); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_RigidBodyState_m_Buffer_Max.impl;

DATA Base_samples_RigidBodyState_m_Buffer
END Base_samples_RigidBodyState_m_Buffer;

DATA IMPLEMENTATION Base_samples_RigidBodyState_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_RigidBodyState_m
SUBCOMPONENTS
    Buffer : data Base_samples_RigidBodyState_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_RigidBodyState_m_Buffer.impl;

DATA T_Boolean
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/taste-types.asn");
    Ada_Package_Name => "TASTE_BasicTypes";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 1; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "T-Boolean";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aBOOLEAN;
END T_Boolean;

DATA IMPLEMENTATION T_Boolean.impl
END T_Boolean.impl;

DATA T_Boolean_Buffer_Max
END T_Boolean_Buffer_Max;

DATA IMPLEMENTATION T_Boolean_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type T_Boolean
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END T_Boolean_Buffer_Max.impl;

DATA T_Boolean_Buffer
END T_Boolean_Buffer;

DATA IMPLEMENTATION T_Boolean_Buffer.impl
    -- Buffer to hold a marshalled data of type T_Boolean
SUBCOMPONENTS
    Buffer : data T_Boolean_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END T_Boolean_Buffer.impl;

DATA T_UInt32
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/taste-types.asn");
    Ada_Package_Name => "TASTE_BasicTypes";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 8; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "T-UInt32";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aINTEGER;
END T_UInt32;

DATA IMPLEMENTATION T_UInt32.impl
END T_UInt32.impl;

DATA T_UInt32_Buffer_Max
END T_UInt32_Buffer_Max;

DATA IMPLEMENTATION T_UInt32_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type T_UInt32
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END T_UInt32_Buffer_Max.impl;

DATA T_UInt32_Buffer
END T_UInt32_Buffer;

DATA IMPLEMENTATION T_UInt32_Buffer.impl
    -- Buffer to hold a marshalled data of type T_UInt32
SUBCOMPONENTS
    Buffer : data T_UInt32_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END T_UInt32_Buffer.impl;

DATA T_Int32
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/taste-types.asn");
    Ada_Package_Name => "TASTE_BasicTypes";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 8; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "T-Int32";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aINTEGER;
END T_Int32;

DATA IMPLEMENTATION T_Int32.impl
END T_Int32.impl;

DATA T_Int32_Buffer_Max
END T_Int32_Buffer_Max;

DATA IMPLEMENTATION T_Int32_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type T_Int32
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END T_Int32_Buffer_Max.impl;

DATA T_Int32_Buffer
END T_Int32_Buffer;

DATA IMPLEMENTATION T_Int32_Buffer.impl
    -- Buffer to hold a marshalled data of type T_Int32
SUBCOMPONENTS
    Buffer : data T_Int32_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END T_Int32_Buffer.impl;

DATA Base_samples_SonarBeam
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 274; suggested aligned message buffer is...
    Source_Data_Size => 280 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-SonarBeam";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_SonarBeam;

DATA IMPLEMENTATION Base_samples_SonarBeam.impl
END Base_samples_SonarBeam.impl;

DATA Base_samples_SonarBeam_Buffer_Max
END Base_samples_SonarBeam_Buffer_Max;

DATA IMPLEMENTATION Base_samples_SonarBeam_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_SonarBeam
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (280); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_SonarBeam_Buffer_Max.impl;

DATA Base_samples_SonarBeam_Buffer
END Base_samples_SonarBeam_Buffer;

DATA IMPLEMENTATION Base_samples_SonarBeam_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_SonarBeam
SUBCOMPONENTS
    Buffer : data Base_samples_SonarBeam_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_SonarBeam_Buffer.impl;

DATA Base_JointTransform_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 442; suggested aligned message buffer is...
    Source_Data_Size => 448 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-JointTransform-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_JointTransform_m;

DATA IMPLEMENTATION Base_JointTransform_m.impl
END Base_JointTransform_m.impl;

DATA Base_JointTransform_m_Buffer_Max
END Base_JointTransform_m_Buffer_Max;

DATA IMPLEMENTATION Base_JointTransform_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_JointTransform_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (448); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_JointTransform_m_Buffer_Max.impl;

DATA Base_JointTransform_m_Buffer
END Base_JointTransform_m_Buffer;

DATA IMPLEMENTATION Base_JointTransform_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_JointTransform_m
SUBCOMPONENTS
    Buffer : data Base_JointTransform_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_JointTransform_m_Buffer.impl;

DATA Base_Waypoint_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 79; suggested aligned message buffer is...
    Source_Data_Size => 80 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-Waypoint-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_Waypoint_m;

DATA IMPLEMENTATION Base_Waypoint_m.impl
END Base_Waypoint_m.impl;

DATA Base_Waypoint_m_Buffer_Max
END Base_Waypoint_m_Buffer_Max;

DATA IMPLEMENTATION Base_Waypoint_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_Waypoint_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (80); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_Waypoint_m_Buffer_Max.impl;

DATA Base_Waypoint_m_Buffer
END Base_Waypoint_m_Buffer;

DATA IMPLEMENTATION Base_Waypoint_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_Waypoint_m
SUBCOMPONENTS
    Buffer : data Base_Waypoint_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_Waypoint_m_Buffer.impl;

DATA Base_samples_Wrenches
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 55910; suggested aligned message buffer is...
    Source_Data_Size => 55912 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-Wrenches";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_Wrenches;

DATA IMPLEMENTATION Base_samples_Wrenches.impl
END Base_samples_Wrenches.impl;

DATA Base_samples_Wrenches_Buffer_Max
END Base_samples_Wrenches_Buffer_Max;

DATA IMPLEMENTATION Base_samples_Wrenches_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_Wrenches
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (55912); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_Wrenches_Buffer_Max.impl;

DATA Base_samples_Wrenches_Buffer
END Base_samples_Wrenches_Buffer;

DATA IMPLEMENTATION Base_samples_Wrenches_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_Wrenches
SUBCOMPONENTS
    Buffer : data Base_samples_Wrenches_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_Wrenches_Buffer.impl;

DATA Base_JointTrajectory
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 13001; suggested aligned message buffer is...
    Source_Data_Size => 13008 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-JointTrajectory";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCEOF;
END Base_JointTrajectory;

DATA IMPLEMENTATION Base_JointTrajectory.impl
END Base_JointTrajectory.impl;

DATA Base_JointTrajectory_Buffer_Max
END Base_JointTrajectory_Buffer_Max;

DATA IMPLEMENTATION Base_JointTrajectory_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_JointTrajectory
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (13008); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_JointTrajectory_Buffer_Max.impl;

DATA Base_JointTrajectory_Buffer
END Base_JointTrajectory_Buffer;

DATA IMPLEMENTATION Base_JointTrajectory_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_JointTrajectory
SUBCOMPONENTS
    Buffer : data Base_JointTrajectory_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_JointTrajectory_Buffer.impl;

DATA Base_samples_frame_frame_size_t
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 16; suggested aligned message buffer is...
    Source_Data_Size => 16 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-samples-frame-frame-size-t";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_samples_frame_frame_size_t;

DATA IMPLEMENTATION Base_samples_frame_frame_size_t.impl
END Base_samples_frame_frame_size_t.impl;

DATA Base_samples_frame_frame_size_t_Buffer_Max
END Base_samples_frame_frame_size_t_Buffer_Max;

DATA IMPLEMENTATION Base_samples_frame_frame_size_t_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_samples_frame_frame_size_t
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (16); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_samples_frame_frame_size_t_Buffer_Max.impl;

DATA Base_samples_frame_frame_size_t_Buffer
END Base_samples_frame_frame_size_t_Buffer;

DATA IMPLEMENTATION Base_samples_frame_frame_size_t_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_samples_frame_frame_size_t
SUBCOMPONENTS
    Buffer : data Base_samples_frame_frame_size_t_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_samples_frame_frame_size_t_Buffer.impl;

DATA Base_NamedVector_Base_JointTransform
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 128816; suggested aligned message buffer is...
    Source_Data_Size => 128816 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-NamedVector-Base-JointTransform";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_NamedVector_Base_JointTransform;

DATA IMPLEMENTATION Base_NamedVector_Base_JointTransform.impl
END Base_NamedVector_Base_JointTransform.impl;

DATA Base_NamedVector_Base_JointTransform_Buffer_Max
END Base_NamedVector_Base_JointTransform_Buffer_Max;

DATA IMPLEMENTATION Base_NamedVector_Base_JointTransform_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_NamedVector_Base_JointTransform
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (128816); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_NamedVector_Base_JointTransform_Buffer_Max.impl;

DATA Base_NamedVector_Base_JointTransform_Buffer
END Base_NamedVector_Base_JointTransform_Buffer;

DATA IMPLEMENTATION Base_NamedVector_Base_JointTransform_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_NamedVector_Base_JointTransform
SUBCOMPONENTS
    Buffer : data Base_NamedVector_Base_JointTransform_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_NamedVector_Base_JointTransform_Buffer.impl;

DATA Base_Trajectory_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 5237; suggested aligned message buffer is...
    Source_Data_Size => 5240 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-Trajectory-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_Trajectory_m;

DATA IMPLEMENTATION Base_Trajectory_m.impl
END Base_Trajectory_m.impl;

DATA Base_Trajectory_m_Buffer_Max
END Base_Trajectory_m_Buffer_Max;

DATA IMPLEMENTATION Base_Trajectory_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_Trajectory_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (5240); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_Trajectory_m_Buffer_Max.impl;

DATA Base_Trajectory_m_Buffer
END Base_Trajectory_m_Buffer;

DATA IMPLEMENTATION Base_Trajectory_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_Trajectory_m
SUBCOMPONENTS
    Buffer : data Base_Trajectory_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_Trajectory_m_Buffer.impl;

DATA Base_commands_LinearAngular6DCommand_m
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 87; suggested aligned message buffer is...
    Source_Data_Size => 88 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-commands-LinearAngular6DCommand-m";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_commands_LinearAngular6DCommand_m;

DATA IMPLEMENTATION Base_commands_LinearAngular6DCommand_m.impl
END Base_commands_LinearAngular6DCommand_m.impl;

DATA Base_commands_LinearAngular6DCommand_m_Buffer_Max
END Base_commands_LinearAngular6DCommand_m_Buffer_Max;

DATA IMPLEMENTATION Base_commands_LinearAngular6DCommand_m_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_commands_LinearAngular6DCommand_m
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (88); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_commands_LinearAngular6DCommand_m_Buffer_Max.impl;

DATA Base_commands_LinearAngular6DCommand_m_Buffer
END Base_commands_LinearAngular6DCommand_m_Buffer;

DATA IMPLEMENTATION Base_commands_LinearAngular6DCommand_m_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_commands_LinearAngular6DCommand_m
SUBCOMPONENTS
    Buffer : data Base_commands_LinearAngular6DCommand_m_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_commands_LinearAngular6DCommand_m_Buffer.impl;

DATA Wrappers_Vector3d
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 40; suggested aligned message buffer is...
    Source_Data_Size => 40 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Wrappers-Vector3d";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Wrappers_Vector3d;

DATA IMPLEMENTATION Wrappers_Vector3d.impl
END Wrappers_Vector3d.impl;

DATA Wrappers_Vector3d_Buffer_Max
END Wrappers_Vector3d_Buffer_Max;

DATA IMPLEMENTATION Wrappers_Vector3d_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Wrappers_Vector3d
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (40); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Wrappers_Vector3d_Buffer_Max.impl;

DATA Wrappers_Vector3d_Buffer
END Wrappers_Vector3d_Buffer;

DATA IMPLEMENTATION Wrappers_Vector3d_Buffer.impl
    -- Buffer to hold a marshalled data of type Wrappers_Vector3d
SUBCOMPONENTS
    Buffer : data Wrappers_Vector3d_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Wrappers_Vector3d_Buffer.impl;

DATA T_UInt16
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/taste-extended.asn");
    Ada_Package_Name => "TASTE_ExtendedTypes";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 8; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "T-UInt16";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aINTEGER;
END T_UInt16;

DATA IMPLEMENTATION T_UInt16.impl
END T_UInt16.impl;

DATA T_UInt16_Buffer_Max
END T_UInt16_Buffer_Max;

DATA IMPLEMENTATION T_UInt16_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type T_UInt16
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END T_UInt16_Buffer_Max.impl;

DATA T_UInt16_Buffer
END T_UInt16_Buffer;

DATA IMPLEMENTATION T_UInt16_Buffer.impl
    -- Buffer to hold a marshalled data of type T_UInt16
SUBCOMPONENTS
    Buffer : data T_UInt16_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END T_UInt16_Buffer.impl;

DATA Base_TimeStamped_Base_commands_Motion2D
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 47; suggested aligned message buffer is...
    Source_Data_Size => 48 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Base-TimeStamped-Base-commands-Motion2D";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aSEQUENCE;
END Base_TimeStamped_Base_commands_Motion2D;

DATA IMPLEMENTATION Base_TimeStamped_Base_commands_Motion2D.impl
END Base_TimeStamped_Base_commands_Motion2D.impl;

DATA Base_TimeStamped_Base_commands_Motion2D_Buffer_Max
END Base_TimeStamped_Base_commands_Motion2D_Buffer_Max;

DATA IMPLEMENTATION Base_TimeStamped_Base_commands_Motion2D_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Base_TimeStamped_Base_commands_Motion2D
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (48); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Base_TimeStamped_Base_commands_Motion2D_Buffer_Max.impl;

DATA Base_TimeStamped_Base_commands_Motion2D_Buffer
END Base_TimeStamped_Base_commands_Motion2D_Buffer;

DATA IMPLEMENTATION Base_TimeStamped_Base_commands_Motion2D_Buffer.impl
    -- Buffer to hold a marshalled data of type Base_TimeStamped_Base_commands_Motion2D
SUBCOMPONENTS
    Buffer : data Base_TimeStamped_Base_commands_Motion2D_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Base_TimeStamped_Base_commands_Motion2D_Buffer.impl;

DATA Wrappers_geometry_SplineType
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("/home/taste/esrocos_workspace/install/types/base/base.asn");
    Ada_Package_Name => "Base_Types";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 4; suggested aligned message buffer is...
    Source_Data_Size => 8 B;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "Wrappers-geometry-SplineType";
    -- what kind of type is this?
    assert_properties::ASN1_Basic_Type =>aENUMERATED;
END Wrappers_geometry_SplineType;

DATA IMPLEMENTATION Wrappers_geometry_SplineType.impl
END Wrappers_geometry_SplineType.impl;

DATA Wrappers_geometry_SplineType_Buffer_Max
END Wrappers_geometry_SplineType_Buffer_Max;

DATA IMPLEMENTATION Wrappers_geometry_SplineType_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type Wrappers_geometry_SplineType
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (data ASSERT_Types::Stream_Element);
END Wrappers_geometry_SplineType_Buffer_Max.impl;

DATA Wrappers_geometry_SplineType_Buffer
END Wrappers_geometry_SplineType_Buffer;

DATA IMPLEMENTATION Wrappers_geometry_SplineType_Buffer.impl
    -- Buffer to hold a marshalled data of type Wrappers_geometry_SplineType
SUBCOMPONENTS
    Buffer : data Wrappers_geometry_SplineType_Buffer_Max.impl;
    Length : data Base_Types::uint32;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END Wrappers_geometry_SplineType_Buffer.impl;

SYSTEM Taste_DataView
END    Taste_DataView;

SYSTEM IMPLEMENTATION Taste_DataView.others
SUBCOMPONENTS
   Wrappers_AngleAxisd : DATA Wrappers_AngleAxisd.impl;
   Wrappers_Matrix6d : DATA Wrappers_Matrix6d.impl;
   T_Time : DATA T_Time.impl;
   T_String : DATA T_String.impl;
   Base_geometry_SplineBase_CoordinateType : DATA Base_geometry_SplineBase_CoordinateType.impl;
   Wrappers_Vector2d : DATA Wrappers_Vector2d.impl;
   Base_JointTransformVector_m : DATA Base_JointTransformVector_m.impl;
   Base_samples_frame_FramePair : DATA Base_samples_frame_FramePair.impl;
   Base_Time : DATA Base_Time.impl;
   Base_Temperature : DATA Base_Temperature.impl;
   Wrappers_VectorXd : DATA Wrappers_VectorXd.impl;
   Base_TwistWithCovariance_m : DATA Base_TwistWithCovariance_m.impl;
   Base_Waypoint : DATA Base_Waypoint.impl;
   Dummy2Base_T : DATA Dummy2Base_T.impl;
   Base_Pose : DATA Base_Pose.impl;
   Base_JointLimitRange : DATA Base_JointLimitRange.impl;
   Base_samples_frame_Frame : DATA Base_samples_frame_Frame.impl;
   Base_samples_Pointcloud_m : DATA Base_samples_Pointcloud_m.impl;
   Base_Wrench : DATA Base_Wrench.impl;
   T_Float : DATA T_Float.impl;
   Base_samples_IMUSensors : DATA Base_samples_IMUSensors.impl;
   Base_samples_SonarScan : DATA Base_samples_SonarScan.impl;
   Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE : DATA Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE.impl;
   Base_samples_RigidBodyState : DATA Base_samples_RigidBodyState.impl;
   Base_NamedVector_Base_Wrench : DATA Base_NamedVector_Base_Wrench.impl;
   T_Double : DATA T_Double.impl;
   Base_JointState_MODE : DATA Base_JointState_MODE.impl;
   Base_samples_DistanceImage : DATA Base_samples_DistanceImage.impl;
   Base_samples_RigidBodyAcceleration : DATA Base_samples_RigidBodyAcceleration.impl;
   Base_JointTransformVector : DATA Base_JointTransformVector.impl;
   Base_Pose_m : DATA Base_Pose_m.impl;
   Base_samples_BodyState_m : DATA Base_samples_BodyState_m.impl;
   Base_Pose2D : DATA Base_Pose2D.impl;
   Base_NamedVector_base_JointTransform_m : DATA Base_NamedVector_base_JointTransform_m.impl;
   Base_Angle : DATA Base_Angle.impl;
   Base_TwistWithCovariance : DATA Base_TwistWithCovariance.impl;
   Base_NamedVector_Base_JointState : DATA Base_NamedVector_Base_JointState.impl;
   Base_Pose2D_m : DATA Base_Pose2D_m.impl;
   Base_samples_LASER_RANGE_ERRORS : DATA Base_samples_LASER_RANGE_ERRORS.impl;
   Base_samples_DepthMap_UNIT_AXIS : DATA Base_samples_DepthMap_UNIT_AXIS.impl;
   Base_Wrench_m : DATA Base_Wrench_m.impl;
   Std_orogen_typekits_mtype_std_vector_base_Wrench : DATA Std_orogen_typekits_mtype_std_vector_base_Wrench.impl;
   Base_samples_BodyState : DATA Base_samples_BodyState.impl;
   T_UInt64 : DATA T_UInt64.impl;
   DummyBase_T : DATA DummyBase_T.impl;
   T_Int64 : DATA T_Int64.impl;
   Wrappers_Matrix4d : DATA Wrappers_Matrix4d.impl;
   Std_orogen_typekits_mtype_std_vector_base_JointTransform : DATA Std_orogen_typekits_mtype_std_vector_base_JointTransform.impl;
   Base_PoseUpdateThreshold : DATA Base_PoseUpdateThreshold.impl;
   Base_NamedVector_Base_JointLimitRange : DATA Base_NamedVector_Base_JointLimitRange.impl;
   Base_Trajectory : DATA Base_Trajectory.impl;
   Base_NamedVector_Base_JointTrajectory : DATA Base_NamedVector_Base_JointTrajectory.impl;
   Base_JointTransform : DATA Base_JointTransform.impl;
   Std_orogen_typekits_mtype_std_vector_base_Waypoint : DATA Std_orogen_typekits_mtype_std_vector_base_Waypoint.impl;
   Base_samples_DepthMap : DATA Base_samples_DepthMap.impl;
   T_Int8 : DATA T_Int8.impl;
   Base_samples_DepthMap_PROJECTION_TYPE : DATA Base_samples_DepthMap_PROJECTION_TYPE.impl;
   Base_samples_Pointcloud : DATA Base_samples_Pointcloud.impl;
   Base_Pressure : DATA Base_Pressure.impl;
   Base_samples_Pressure : DATA Base_samples_Pressure.impl;
   Wrappers_Quaterniond : DATA Wrappers_Quaterniond.impl;
   Base_samples_frame_frame_attrib_t : DATA Base_samples_frame_frame_attrib_t.impl;
   Std_orogen_typekits_mtype_std_vector_base_Trajectory : DATA Std_orogen_typekits_mtype_std_vector_base_Trajectory.impl;
   Base_Time_Resolution : DATA Base_Time_Resolution.impl;
   Base_NamedVector_base_Wrench_m : DATA Base_NamedVector_base_Wrench_m.impl;
   Base_samples_LaserScan : DATA Base_samples_LaserScan.impl;
   T_Int16 : DATA T_Int16.impl;
   Base_samples_Wrenches_m : DATA Base_samples_Wrenches_m.impl;
   Base_samples_Sonar : DATA Base_samples_Sonar.impl;
   Base_samples_IMUSensors_m : DATA Base_samples_IMUSensors_m.impl;
   Wrappers_Matrix2d : DATA Wrappers_Matrix2d.impl;
   Wrappers_Vector6d : DATA Wrappers_Vector6d.impl;
   Base_JointLimits : DATA Base_JointLimits.impl;
   Base_samples_Motion2D : DATA Base_samples_Motion2D.impl;
   Base_samples_Wrench_m : DATA Base_samples_Wrench_m.impl;
   Base_JointState : DATA Base_JointState.impl;
   Base_TransformWithCovariance : DATA Base_TransformWithCovariance.impl;
   Base_commands_Speed6D : DATA Base_commands_Speed6D.impl;
   Wrappers_MatrixXd : DATA Wrappers_MatrixXd.impl;
   T_UInt8 : DATA T_UInt8.impl;
   Base_samples_frame_frame_mode_t : DATA Base_samples_frame_frame_mode_t.impl;
   Base_LinearAngular6DCommand : DATA Base_LinearAngular6DCommand.impl;
   Base_commands_Joints : DATA Base_commands_Joints.impl;
   Wrappers_geometry_Spline : DATA Wrappers_geometry_Spline.impl;
   Base_commands_Motion2D : DATA Base_commands_Motion2D.impl;
   Base_samples_frame_frame_status_t : DATA Base_samples_frame_frame_status_t.impl;
   Wrappers_Vector4d : DATA Wrappers_Vector4d.impl;
   Base_samples_RigidBodyAcceleration_m : DATA Base_samples_RigidBodyAcceleration_m.impl;
   Base_JointsTrajectory : DATA Base_JointsTrajectory.impl;
   Base_samples_Wrench : DATA Base_samples_Wrench.impl;
   Wrappers_Matrix3d : DATA Wrappers_Matrix3d.impl;
   Std_vector_Wrappers_Vector4d : DATA Std_vector_Wrappers_Vector4d.impl;
   Base_TransformWithCovariance_m : DATA Base_TransformWithCovariance_m.impl;
   Base_samples_RigidBodyState_m : DATA Base_samples_RigidBodyState_m.impl;
   T_Boolean : DATA T_Boolean.impl;
   T_UInt32 : DATA T_UInt32.impl;
   T_Int32 : DATA T_Int32.impl;
   Base_samples_SonarBeam : DATA Base_samples_SonarBeam.impl;
   Base_JointTransform_m : DATA Base_JointTransform_m.impl;
   Base_Waypoint_m : DATA Base_Waypoint_m.impl;
   Base_samples_Wrenches : DATA Base_samples_Wrenches.impl;
   Base_JointTrajectory : DATA Base_JointTrajectory.impl;
   Base_samples_frame_frame_size_t : DATA Base_samples_frame_frame_size_t.impl;
   Base_NamedVector_Base_JointTransform : DATA Base_NamedVector_Base_JointTransform.impl;
   Base_Trajectory_m : DATA Base_Trajectory_m.impl;
   Base_commands_LinearAngular6DCommand_m : DATA Base_commands_LinearAngular6DCommand_m.impl;
   Wrappers_Vector3d : DATA Wrappers_Vector3d.impl;
   T_UInt16 : DATA T_UInt16.impl;
   Base_TimeStamped_Base_commands_Motion2D : DATA Base_TimeStamped_Base_commands_Motion2D.impl;
   Wrappers_geometry_SplineType : DATA Wrappers_geometry_SplineType.impl;
END Taste_DataView.others;
end DataView;



package ocarina_buses

public

bus generic_bus
end generic_bus;

bus implementation generic_bus.i
end generic_bus.i;

bus dummy_bus
end dummy_bus;

bus implementation dummy_bus.i
end dummy_bus.i;

bus ip
end ip;

bus implementation ip.pohic
end ip.pohic;

bus implementation ip.i
subcomponents
   asn      : virtual bus asn1.i;
   pohic    : virtual bus pohi.c;
   pohiada  : virtual bus pohi.ada;
end ip.i;

bus implementation ip.pohiada
end ip.pohiada;

bus spacewire
end spacewire;

bus implementation spacewire.generic
end spacewire.generic;

bus serial
end serial;

bus implementation serial.generic
end serial.generic;

bus bluetooth
end bluetooth;

bus implementation bluetooth.crazyflie
end bluetooth.crazyflie;


----------------------
--  Virtual buses  --
----------------------

virtual bus raw
end raw;

virtual bus implementation raw.i
end raw.i;

virtual bus asn1
end asn1;

virtual bus implementation asn1.i
end asn1.i;

virtual bus pohi
end pohi;

virtual bus implementation pohi.c
end pohi.c;

virtual bus implementation pohi.ada
end pohi.ada;

end ocarina_buses;
package ocarina_drivers
public

  with deployment;

  with ocarina_buses;

  with Data_Model;
  with Base_Types;

  with ocarina_drivers_leon_serial;

  with ocarina_drivers_rasta_1553;
  with ocarina_drivers_rasta_serial;
  with ocarina_drivers_rasta_spacewire;
  with ocarina_drivers_rtems_ne2000;
  with ocarina_drivers_grspw_packet;
  with ocarina_drivers_apbuart_serial;
  with ocarina_drivers_greth;

  with ocarina_drivers_star_dundee_spacewire_brick;

  with ocarina_drivers_udp_exarm;
  with ocarina_drivers_serial;

  with ocarina_drivers_ip_pohic;

  with ocarina_drivers_exarm_ni_6071e_analog;
  with ocarina_drivers_exarm_ni_6071e_digital;

  with ocarina_drivers_generic_keyboard;

  with GRUART;
  with GRSPW;
  with Native_UART;
  with TCP_IP_Protocol;
  with STM32F4_UART;
  with Crazyflie_BLE;
  with Client_BLE;

  ------------------------
  -- Configuration Type --
  ------------------------

   data configuration_type_ip
   properties
      Type_Source_Name                 => "IP-Conf-T";
      Deployment::ASN1_Module_Name     => "POHICDRIVER-IP";
      Source_Language                  => (ASN1);
      Source_Text                      => ("/home/taste/tool-inst/include/ocarina/runtime/polyorb-hi-c/src/drivers/configuration/ip.asn" , "drivers/configuration/ip.h");
   end configuration_type_ip;

   data configuration_type_serial
   properties
      Type_Source_Name              => "Serial-Conf-T";
      Deployment::ASN1_Module_Name  => "POHICDRIVER-UART";
      Source_Language               => (ASN1);
      Source_Text                   => ("/home/taste/tool-inst/include/ocarina/runtime/polyorb-hi-c/src/drivers/configuration/serial.asn", "drivers/configuration/serial.h");
   end configuration_type_serial;

   data configuration_type_spacewire
   properties
      Type_Source_Name              => "Spacewire-Conf-T";
      Deployment::ASN1_Module_Name  => "POHICDRIVER-SPACEWIRE";
      Source_Language               => (ASN1);
      Source_Text                   => ("/home/taste/tool-inst/include/ocarina/runtime/polyorb-hi-c/src/drivers/configuration/spacewire.asn", "drivers/configuration/spacewire.h");
   end configuration_type_spacewire;

   data configuration_type_bluetooth
   properties
      Type_Source_Name              => "Bluetooth-Conf-T";
      Deployment::ASN1_Module_Name  => "POHICDRIVER-BLUETOOTH";
      Source_Language               => (ASN1);
      Source_Text                   => ("/home/taste/tool-inst/include/ocarina/runtime/polyorb-hi-c/src/drivers/configuration/bluetooth.asn", "drivers/configuration/bluetooth.h");
   end configuration_type_bluetooth;

  --------------
  -- Keyboard --
  --------------

  device generic_keyboard
  features
    key_pressed  : out data port Base_Types::Character;
  properties
    Deployment::Driver_Name    => "generic_keyboard";
    Device_Driver              => classifier (ocarina_drivers_generic_keyboard::generic_keyboard_driver.i);
    Initialize_Entrypoint      => classifier (ocarina_drivers_generic_keyboard::spg_generic_keyboard_init);
  end generic_keyboard;

  device implementation generic_keyboard.linux
  end generic_keyboard.linux;


  -------------------
  -- LEON ETHERNET --
  -------------------

  device leon_ethernet
  features
    link : requires bus access ocarina_buses::ip.i;
  end leon_ethernet;

  device implementation leon_ethernet.raw
  properties
    Deployment::Driver_Name    => "eth_leon";
    Device_Driver              => classifier (ocarina_drivers_leon_eth::eth_driver.leon);
    Initialize_Entrypoint      => classifier (ocarina_drivers_leon_eth::spg_leon_eth_init);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end leon_ethernet.raw;

  device implementation leon_ethernet.greth
  properties
    Deployment::Driver_Name    => "greth";
    Device_Driver              => classifier (ocarina_drivers_greth::eth_driver.leon);
    Initialize_Entrypoint      => classifier (ocarina_drivers_greth::spg_greth_init);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end leon_ethernet.greth;

  -----------------
  -- LEON SERIAL --
  -----------------

  device leon_serial
  features
    link : requires bus access ocarina_buses::serial.generic;
  end leon_serial;

  device implementation leon_serial.raw
  properties
    Deployment::Driver_Name    => "serial_leon";
    Device_Driver              => classifier (ocarina_drivers_leon_serial::serial_driver.leon);
    Initialize_Entrypoint      => classifier (ocarina_drivers_leon_serial::spg_serial_init_leon);
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::raw.i));
  end leon_serial.raw;

  device implementation leon_serial.raw_sender
  properties
    Deployment::Driver_Name    => "serial_leon_sender";
    Device_Driver              => classifier (ocarina_drivers_leon_serial::serial_driver.leon_sender);
    Initialize_Entrypoint      => classifier (ocarina_drivers_leon_serial::spg_serial_init_leon_sender);
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::raw.i));
  end leon_serial.raw_sender;

  ----------------
  -- RASTA 1553 --
  ----------------

  device rasta_1553
  end rasta_1553;

  device implementation rasta_1553.terminal
  properties
    Deployment::Driver_Name    => "1553_rasta";
    Device_Driver              => classifier (ocarina_drivers_rasta_1553::if1553_driver.rasta_terminal);
    Initialize_Entrypoint      => classifier (ocarina_drivers_rasta_1553::spg_1553_init_rasta_terminal);
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::pohi.c));
  end rasta_1553.terminal;

  device implementation rasta_1553.controller_sender_only
  properties
    Deployment::Driver_Name    => "1553_rasta";
    Device_Driver              => classifier (ocarina_drivers_rasta_1553::if1553_driver.rasta_controller_sender_only);
    Initialize_Entrypoint      => classifier (ocarina_drivers_rasta_1553::spg_1553_init_rasta_controller);
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::pohi.c));
  end rasta_1553.controller_sender_only;

  ------------------
  -- RASTA SERIAL --
  ------------------

  device rasta_serial
  features
    link : requires bus access ocarina_buses::serial.generic;
  end rasta_serial;

  device implementation rasta_serial.raw
  properties
    Deployment::Driver_Name    => "serial_rasta";
    Device_Driver              => classifier (ocarina_drivers_rasta_serial::serial_driver.rasta);
    Initialize_Entrypoint      => classifier (ocarina_drivers_rasta_serial::spg_serial_init_rasta);
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::raw.i));
  end rasta_serial.raw;

  device implementation rasta_serial.apbuart_drvmgr
  properties
    Deployment::Driver_Name    => "apbuart_serial";
    Device_Driver              => classifier (ocarina_drivers_apbuart_serial::serial_driver.impl);
    Initialize_Entrypoint      => classifier (ocarina_drivers_apbuart_serial::spg_serial_init);
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::raw.i));
  end rasta_serial.apbuart_drvmgr;

  device implementation rasta_serial.pohiada
  properties
    Deployment::Driver_Name    => "serial_rasta";
    Device_Driver =>  classifier (GRUART::Driver_GRUART_Protocol.impl);
    Initialize_Entrypoint => classifier (GRUART::Initialize);
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::raw.i));
  end rasta_serial.pohiada;

  --------------------------------------------------
  -- USB BRICK (STAR DUNDEE) DEVICE FOR SPACEWIRE --
  --------------------------------------------------

  device usb_brick_spacewire
  features
    link : requires bus access ocarina_buses::spacewire.generic;
  end usb_brick_spacewire;

  device implementation usb_brick_spacewire.pohic
  properties
    Deployment::Driver_Name       => "spacewire_usb_brick";
    Device_Driver                 => classifier (ocarina_drivers_star_dundee_spacewire_brick::driver.usb_brick);
    Initialize_Entrypoint         => classifier (ocarina_drivers_star_dundee_spacewire_brick::spg_init);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end usb_brick_spacewire.pohic;

  ---------------------
  -- RASTA SPACEWIRE --
  ---------------------

  device rasta_spacewire
  features
    link : requires bus access ocarina_buses::spacewire.generic;
  end rasta_spacewire;

  device implementation rasta_spacewire.pohic
  properties
    Deployment::Driver_Name       => "spacewire_rasta";
    Device_Driver                 => classifier (ocarina_drivers_rasta_spacewire::spacewire_driver.rasta);
    Initialize_Entrypoint         => classifier (ocarina_drivers_rasta_spacewire::spg_spacewire_init_rasta);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end rasta_spacewire.pohic;

 device implementation rasta_spacewire.grspw_pohic
  properties
    Deployment::Driver_Name       => "grspw_spacewire";
    Device_Driver                 =>
      classifier (ocarina_drivers_grspw_packet::grspw_packet_driver.rasta);
    Initialize_Entrypoint         =>
      classifier (ocarina_drivers_grspw_packet::spg_grspw_packet_init_rasta);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end rasta_spacewire.grspw_pohic;

  device implementation rasta_spacewire.pohiada
  properties
    Deployment::Driver_Name       => "spacewire_rasta";
    Device_Driver =>  classifier (GRSPW::Driver_GRSPW_Protocol.impl);
    Initialize_Entrypoint => classifier (GRSPW::Initialize);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end rasta_spacewire.pohiada;


  ---------------------
  -- SCOC3 SPACEWIRE --
  ---------------------

  device scoc3_spacewire
  features
    link : requires bus access ocarina_buses::spacewire.generic;
  end scoc3_spacewire;

  device implementation scoc3_spacewire.pohic
  properties
    Deployment::Driver_Name       => "spacewire_scoc3";
    Device_Driver                 => classifier (ocarina_drivers_scoc3_spacewire::driver.i);
    Initialize_Entrypoint         => classifier (ocarina_drivers_scoc3_spacewire::spg_init);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end scoc3_spacewire.pohic;

  ---------------------------
  -- STM32F4 serial driver --
  ---------------------------

  device STM32F4_serial
  features
    link : requires bus access ocarina_buses::serial.generic;
  end STM32F4_serial;

  device implementation STM32F4_serial.pohiada
  properties
    Deployment::Driver_Name       => "serial_STM32F4";
    Device_Driver                 => classifier (STM32F4_UART::driver.STM32F4_UART);
    Initialize_Entrypoint         => classifier (STM32F4_UART::Initialize);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::raw.i));
  end STM32F4_serial.pohiada;

  --------------------------
  -- Crazyflie BLE driver --
  --------------------------

  device Crazyflie_BLE
  features
    link : requires bus access ocarina_buses::bluetooth.crazyflie;
  end Crazyflie_BLE;

  device implementation Crazyflie_BLE.pohiada
  properties
    Deployment::Driver_Name       => "Crazyflie_BLE";
    Device_Driver                 => classifier (Crazyflie_BLE::driver.Crazyflie_BLE);
    Initialize_Entrypoint         => classifier (Crazyflie_BLE::Initialize);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::raw.i));
  end Crazyflie_BLE.pohiada;

  --------------------------
  -- Crazyflie BLE driver --
  --------------------------

  device Client_BLE
  features
    link : requires bus access ocarina_buses::bluetooth.crazyflie;
  end Client_BLE;

  device implementation Client_BLE.pohiada
  properties
    Deployment::Driver_Name       => "Client_BLE";
    Device_Driver                 => classifier (Client_BLE::driver.Client_BLE);
    Initialize_Entrypoint         => classifier (Client_BLE::Initialize);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::raw.i));
  end Client_BLE.pohiada;

  ---------------------------
  -- Generic serial driver --
  ---------------------------

  device generic_serial
  features
    link : requires bus access ocarina_buses::serial.generic;
  end generic_serial;

  device implementation generic_serial.raw
  properties
    Deployment::Driver_Name       => "serial_linux";
    Device_Driver                 => classifier (ocarina_drivers_serial::serial_driver.linux);
    Initialize_Entrypoint         => classifier (ocarina_drivers_serial::spg_serial_init_linux);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::raw.i));
  end generic_serial.raw;

  device implementation generic_serial.pohiada
  properties
    Deployment::Driver_Name       => "serial_linux";
    Device_Driver =>
         classifier (Native_UART::Driver_Native_UART_Protocol.impl);
    Initialize_Entrypoint => classifier (Native_UART::Initialize);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::raw.i));
  end generic_serial.pohiada;

  device implementation generic_serial.raw_sender
  properties
    Deployment::Driver_Name       => "serial_linux_sender";
    Device_Driver                 => classifier (ocarina_drivers_serial::serial_driver.linux_sender);
    Initialize_Entrypoint         => classifier (ocarina_drivers_serial::spg_serial_init_linux_sender);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::raw.i));
  end generic_serial.raw_sender;

  device implementation generic_serial.raw_receiver
  properties
    Deployment::Driver_Name       => "serial_linux_receiver";
    Device_Driver                 => classifier (ocarina_drivers_serial::serial_driver.linux_receiver);
    Initialize_Entrypoint         => classifier (ocarina_drivers_serial::spg_serial_init_linux_receiver);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::raw.i));
  end generic_serial.raw_receiver;

  -------------------------------
  -- Generic sockets/ip driver --
  -------------------------------

  device generic_sockets_ip
  features
    link : requires bus access ocarina_buses::ip.i;
  end generic_sockets_ip;

  device implementation generic_sockets_ip.pohic
  properties
    Deployment::Driver_Name       => "sockets";
    Device_Driver                 => classifier (ocarina_drivers_ip_pohic::sockets_impl.i);
    Initialize_Entrypoint         => classifier (ocarina_drivers_ip_pohic::spg_sockets_init);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end generic_sockets_ip.pohic;

  device implementation generic_sockets_ip.pohiada
  properties
    Deployment::Driver_Name       => "socketsnew";
    Device_Driver => classifier (TCP_IP_Protocol::Driver_TCP_IP_Protocol.impl);
    Initialize_Entrypoint => classifier (TCP_IP_Protocol::Initialize);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end generic_sockets_ip.pohiada;

  ------------------
  -- RTEMS NE2000 --
  ------------------

  device rtems_ne2000
  features
    link : requires bus access ocarina_buses::ip.i;
  end rtems_ne2000;

  device implementation rtems_ne2000.ip_pohic
  properties
    Deployment::Driver_Name       => "rtems_ne2000_sockets";
    Device_Driver                 => classifier (ocarina_drivers_rtems_ne2000::driver.i);
    Initialize_Entrypoint         => classifier (ocarina_drivers_rtems_ne2000::init);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end rtems_ne2000.ip_pohic;

  ------------------------------------------
  --            Exarm UDP driver          --
  ------------------------------------------
  --  This driver is used to communicate  --
  --  with the exarm robot and also       --
  --  the Matlab simulator.               --
  ------------------------------------------

  device exarm_ip
  features
    link : requires bus access ocarina_buses::ip.i;
  end exarm_ip;

  device implementation exarm_ip.vr_udp
  properties
    Deployment::Driver_Name    => "exarm";
    Device_Driver              => classifier (ocarina_drivers_udp_exarm::driver.i);
    Initialize_Entrypoint      => classifier (ocarina_drivers_udp_exarm::init);
  end exarm_ip.vr_udp;

  data exarm_protocol_data
  end exarm_protocol_data;

  data implementation exarm_protocol_data.vr extends ocarina_drivers_udp_exarm::protocol.vr
  properties
    Data_Model::Data_Representation => Struct;
  end exarm_protocol_data.vr;

  data implementation exarm_protocol_data.robot extends ocarina_drivers_udp_exarm::protocol.robot
  properties
    Data_Model::Data_Representation => Struct;
  end exarm_protocol_data.robot;

  ---------------------------------------
  --   Devices for the Exo skeleton    --
  --  National Instruments PCI-6071E   --
  ---------------------------------------
  --  This device is used to make data --
  --  acquisition of the EXARM robot.  --
  ---------------------------------------

  device exarm_ni_6071e_analog
  features
    data1  : out data port Base_Types::Float_64;
    data2  : out data port Base_Types::Float_64;
    data3  : out data port Base_Types::Float_64;
    data4  : out data port Base_Types::Float_64;
    data5  : out data port Base_Types::Float_64;
    data6  : out data port Base_Types::Float_64;
    data7  : out data port Base_Types::Float_64;
    data8  : out data port Base_Types::Float_64;
    data9  : out data port Base_Types::Float_64;
    data10 : out data port Base_Types::Float_64;
    data11 : out data port Base_Types::Float_64;
    data12 : out data port Base_Types::Float_64;
    data13 : out data port Base_Types::Float_64;
    data14 : out data port Base_Types::Float_64;
    data15 : out data port Base_Types::Float_64;
    data16 : out data port Base_Types::Float_64;
  end exarm_ni_6071e_analog;

  device implementation exarm_ni_6071e_analog.i
  properties
    Deployment::Driver_Name    => "exarm_ni_6071e_analog";
    Device_Driver              => classifier (ocarina_drivers_exarm_ni_6071e_analog::driver.i);
    Initialize_Entrypoint      => classifier (ocarina_drivers_exarm_ni_6071e_analog::spg_init);
  end exarm_ni_6071e_analog.i;

  device exarm_ni_6071e_digital
  features
    data1  : out data port Base_Types::Unsigned_8;
    data2  : out data port Base_Types::Unsigned_8;
  end exarm_ni_6071e_digital;

  device implementation exarm_ni_6071e_digital.i
  properties
    Deployment::Driver_Name    => "exarm_ni_6071e_digital";
    Device_Driver              => classifier (ocarina_drivers_exarm_ni_6071e_digital::driver.i);
    Initialize_Entrypoint      => classifier (ocarina_drivers_exarm_ni_6071e_digital::spg_init);
  end exarm_ni_6071e_digital.i;

end ocarina_drivers;
package ocarina_types

public

with Data_Model;

data integer
end integer;

data implementation integer.i
properties
   Data_Model::Data_Representation => integer;
end integer.i;

data float
end float;

data implementation float.i
properties
   Data_Model::Data_Representation => float;
end float.i;

data boolean
end boolean;

data implementation boolean.i
properties
   Data_Model::Data_Representation => boolean;
end boolean.i;

end ocarina_types;
package ocarina_drivers_exarm_ni_6071e_analog

public

with Base_Types;
with Deployment;

subprogram spg_init
properties
   Source_Language   => (C);
   Source_Name       => "__po_hi_c_driver_exarm_ni_6071e_analog_init";
end spg_init;


subprogram spg_poller
features
   data1  : out parameter Base_Types::Float_64;
   data2  : out parameter Base_Types::Float_64;
   data3  : out parameter Base_Types::Float_64;
   data4  : out parameter Base_Types::Float_64;
   data5  : out parameter Base_Types::Float_64;
   data6  : out parameter Base_Types::Float_64;
   data7  : out parameter Base_Types::Float_64;
   data8  : out parameter Base_Types::Float_64;
   data9  : out parameter Base_Types::Float_64;
   data10 : out parameter Base_Types::Float_64;
   data11 : out parameter Base_Types::Float_64;
   data12 : out parameter Base_Types::Float_64;
   data13 : out parameter Base_Types::Float_64;
   data14 : out parameter Base_Types::Float_64;
   data15 : out parameter Base_Types::Float_64;
   data16 : out parameter Base_Types::Float_64;
properties
   Source_Language   => (C);
   Source_Name       => "__po_hi_c_driver_exarm_ni_6071e_analog_poller";
end spg_poller;


thread thr_poller
features
   data1  : out data port Base_Types::Float_64;
   data2  : out data port Base_Types::Float_64;
   data3  : out data port Base_Types::Float_64;
   data4  : out data port Base_Types::Float_64;
   data5  : out data port Base_Types::Float_64;
   data6  : out data port Base_Types::Float_64;
   data7  : out data port Base_Types::Float_64;
   data8  : out data port Base_Types::Float_64;
   data9  : out data port Base_Types::Float_64;
   data10 : out data port Base_Types::Float_64;
   data11 : out data port Base_Types::Float_64;
   data12 : out data port Base_Types::Float_64;
   data13 : out data port Base_Types::Float_64;
   data14 : out data port Base_Types::Float_64;
   data15 : out data port Base_Types::Float_64;
   data16 : out data port Base_Types::Float_64;
end thr_poller;

thread implementation thr_poller.i
calls
        mycall : {
          pspg : subprogram spg_poller;
        };
connections
   parameter pspg.data1 -> data1;
   parameter pspg.data2 -> data2;
   parameter pspg.data3 -> data3;
   parameter pspg.data4 -> data4;
   parameter pspg.data5 -> data5;
   parameter pspg.data6 -> data6;
   parameter pspg.data7 -> data7;
   parameter pspg.data8 -> data8;
   parameter pspg.data9 -> data9;
   parameter pspg.data10 -> data10;
   parameter pspg.data11 -> data11;
   parameter pspg.data12 -> data12;
   parameter pspg.data13 -> data13;
   parameter pspg.data14 -> data14;
   parameter pspg.data15 -> data15;
   parameter pspg.data16 -> data16;
properties
   Period => 100 ms;
   Dispatch_Protocol => Periodic;
end thr_poller.i;


abstract driver
features
   data1  : out data port Base_Types::Float_64;
   data2  : out data port Base_Types::Float_64;
   data3  : out data port Base_Types::Float_64;
   data4  : out data port Base_Types::Float_64;
   data5  : out data port Base_Types::Float_64;
   data6  : out data port Base_Types::Float_64;
   data7  : out data port Base_Types::Float_64;
   data8  : out data port Base_Types::Float_64;
   data9  : out data port Base_Types::Float_64;
   data10 : out data port Base_Types::Float_64;
   data11 : out data port Base_Types::Float_64;
   data12 : out data port Base_Types::Float_64;
   data13 : out data port Base_Types::Float_64;
   data14 : out data port Base_Types::Float_64;
   data15 : out data port Base_Types::Float_64;
   data16 : out data port Base_Types::Float_64;
end driver;

abstract implementation driver.i
subcomponents
   ni6071e_analog_poller : thread thr_poller.i;
connections
   port ni6071e_analog_poller.data1 -> data1;
   port ni6071e_analog_poller.data2 -> data2;
   port ni6071e_analog_poller.data3 -> data3;
   port ni6071e_analog_poller.data4 -> data4;
   port ni6071e_analog_poller.data5 -> data5;
   port ni6071e_analog_poller.data6 -> data6;
   port ni6071e_analog_poller.data7 -> data7;
   port ni6071e_analog_poller.data8 -> data8;
   port ni6071e_analog_poller.data9 -> data9;
   port ni6071e_analog_poller.data10 -> data10;
   port ni6071e_analog_poller.data11 -> data11;
   port ni6071e_analog_poller.data12 -> data12;
   port ni6071e_analog_poller.data13 -> data13;
   port ni6071e_analog_poller.data14 -> data14;
   port ni6071e_analog_poller.data15 -> data15;
   port ni6071e_analog_poller.data16 -> data16;
end driver.i;

end ocarina_drivers_exarm_ni_6071e_analog;
package ocarina_drivers_exarm_ni_6071e_digital

public

with Base_Types;
with Deployment;

subprogram spg_init
properties
   Source_Language   => (C);
   Source_Name       => "__po_hi_c_driver_exarm_ni_6071e_digital_init";
end spg_init;


subprogram spg_poller
features
   data1 : out parameter Base_Types::Unsigned_32;
   data2 : out parameter Base_Types::Unsigned_32;
properties
   Source_Language   => (C);
   Source_Name       => "__po_hi_c_driver_exarm_ni_6071e_digital_poller";
end spg_poller;


thread thr_poller
features
   data1 : out data port Base_Types::Unsigned_32;
   data2 : out data port Base_Types::Unsigned_32;
end thr_poller;

thread implementation thr_poller.i
calls
        mycall : {
          pspg : subprogram spg_poller;
        };
connections
   parameter pspg.data1 -> data1;
   parameter pspg.data2 -> data2;
properties
   Period => 100 ms;
   Dispatch_Protocol => Periodic;
end thr_poller.i;


abstract driver
features
   data1 : out data port Base_Types::Unsigned_32;
   data2 : out data port Base_Types::Unsigned_32;
properties
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end driver;

abstract implementation driver.i
subcomponents
   ni6071e_digital_poller : thread thr_poller.i;
connections
   port ni6071e_digital_poller.data1 -> data1;
   port ni6071e_digital_poller.data2 -> data2;
end driver.i;

end ocarina_drivers_exarm_ni_6071e_digital;
package Generic_Bus
public

  ---------
  -- BUS --
  ---------

  -- Generic bus to model connections between processors and
  -- devices. It is not used by the code generation process, so it is
  -- made fully generic.

  bus Generic_Bus
  end Generic_Bus;

  bus implementation Generic_Bus.impl
  end Generic_Bus.impl;

end Generic_Bus;
package ocarina_drivers_generic_keyboard

public

with Base_Types;
with Deployment;

subprogram spg_generic_keyboard_init
properties
        Source_Language   => (C);
        Source_Name       => "__po_hi_driver_generic_keyboard_init";
end spg_generic_keyboard_init;


thread keyboard_poller
features
   key_pressed : out data port Base_Types::Integer;
end keyboard_poller;

thread implementation keyboard_poller.i
calls
        mycall : {
          pspg : subprogram spg_generic_keyboard_poller;
        };
connections
   parameter pspg.key_pressed -> key_pressed;
properties
   Period => 100ms;
   Dispatch_Protocol => Periodic;
end keyboard_poller.i;


subprogram spg_generic_keyboard_poller
features
   key_pressed : out parameter Base_Types::Integer;
properties
        Source_Language   => (C);
        Source_Name       => "__po_hi_driver_generic_keyboard_poller";
end spg_generic_keyboard_poller;

abstract generic_keyboard_driver
features
   key_pressed : out data port Base_Types::Integer;
properties
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end generic_keyboard_driver;


abstract implementation generic_keyboard_driver.i
subcomponents
   keyboard_receiver : thread       keyboard_poller.i;
connections
   port keyboard_receiver.key_pressed -> key_pressed;
end generic_keyboard_driver.i;


end ocarina_drivers_generic_keyboard;
package Generic_Native

-- This package models a generic native platform with one generic bus.
--
-- Native platforms are GNU/Linux variants, MacOS X, Solaris, Windows,
-- ...

public
  with Deployment;
  with Generic_Bus;

  ---------------
  -- PROCESSOR --
  ---------------

  -- Generic_Processor is the basic description of a processor with
  -- one bus to connect an ethernet adapter. This ethernet adapter is
  -- used through the TCP_IP_Device defined in TCP_IP_Protocol
  -- package.

-- processor Generic_Processor
-- features
--   eth0_tcp_ip : requires bus access Generic_Bus::Generic_Bus.impl;
--   -- One ethernet card, connected to the processor. It is assumed
--   -- later that it is used through a TCP/IP stack
--
-- end Generic_Processor;
--
-- processor implementation Generic_Processor.impl
-- properties
--   Deployment::Execution_Platform => Native;
--   Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
--   Priority_Range => 0 .. 255;
-- end Generic_Processor.impl;

  ------------
  -- MEMORY --
  ------------

  memory Memory_Segment
  end Memory_Segment;

  memory implementation Memory_Segment.impl
  end Memory_Segment.impl;

end Generic_Native;
package GR_CPCI_X4CV

-- This package models the GR-Rasta GR-CPCI-XC4V LEON Compact-PCI
-- Development board by AEROFlex Gaisler.

public
  with Deployment;
  with Generic_Bus;

  ---------------
  -- PROCESSOR --
  ---------------

  -- The Rasta board has one LEON2 processor, 3 SpW cores and several
  -- UARTS.
  --
  -- SpaceWire cores and UARTS are connected to separate bus, of type
  -- Generic_Bus.impl.

  processor LEON2
  features
    spw_core_1 : requires bus access Generic_Bus::Generic_Bus.impl;
    spw_core_2 : requires bus access Generic_Bus::Generic_Bus.impl;
    spw_core_3 : requires bus access Generic_Bus::Generic_Bus.impl;
    -- Three SpaceWire cores

    -- XXX Add UARTS
  end LEON2;

-- processor implementation LEON2.impl
-- properties
--   Deployment::Execution_Platform => LEON_ORK;  -- for using GNATforLEON
--
--   -- Information on the scheduler used by GNATforLEON
--
--   Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
--   Priority_Range => 0 .. 255;
-- end LEON2.impl;

  ------------
  -- MEMORY --
  ------------

  memory Memory_Segment
  end Memory_Segment;

  memory implementation Memory_Segment.impl
  end Memory_Segment.impl;

end GR_CPCI_X4CV;
package GRSPW

-- This package models a SpaceWire-based protocol layer for the
-- PolyORB-HI/Ada AADL runtime, based on the GRSPW chipset from
-- AEROFlex Gaisler. It defines the subprograms and threads to be
-- integrated with the runtime low level interface.
--
-- To configure this interface, you should use the
-- Deployment::Configuration property with the following format:
--     "spacewire Sender_Core_id Receiver_Core_Id"
--
-- e.g.
--
--     spw : device GRSPW::GRSPW_Device
--            {Deployment::Configuration => "spacewire 1 2"};
--

public

   with Deployment;
   with GR_CPCI_X4CV;
   with Generic_Bus;

   ------------
   -- DEVICE --
   ------------

   -- The main entrypoint for this package is this device, it relies
   -- on the 'Implement_As' feature that defines its full
   -- specification.

   device GRSPW_Device
   features
      LVDS_Wire : requires bus access Generic_Bus::Generic_Bus.impl;
      -- Connection to the remote node

   end GRSPW_Device;

   device implementation GRSPW_Device.impl
   properties
      Device_Driver =>
         classifier (GRSPW::Driver_GRSPW_Protocol.impl);
      Initialize_Entrypoint => classifier (GRSPW::Initialize);
   end GRSPW_Device.impl;

   ------------
   -- DRIVER --
   ------------

   -- In AADLv2, we can model the actual implementation of a driver
   -- using an abstract component.

   abstract Driver_GRSPW_Protocol
   properties
      Deployment::Version  => "0.1beta";
      Deployment::Help     => "Write your ASN.1 configuration here";
      Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_spacewire);
   end Driver_GRSPW_Protocol;

   abstract implementation Driver_GRSPW_Protocol.impl
   subcomponents
      receiver : thread Driver_GRSPW_Protocol_thread_receiver.impl;
      sender : subprogram Send;
   end Driver_GRSPW_Protocol.impl;

   -------------
   -- THREADS --
   -------------

   -- This thread handles the execution logic of the protocol
   -- stack. It relies on the previous subprograms to receive
   -- messages.

   thread Driver_GRSPW_Protocol_thread_receiver

      -- This thread is dispatched when an event is detected on the
      -- real hardware. It then calls receive to handle the incoming
      -- event.

   properties
      Dispatch_Protocol => Background;
      Priority          => 12;
   end Driver_GRSPW_Protocol_thread_receiver;

   thread implementation Driver_GRSPW_Protocol_thread_receiver.impl
   calls
      call1 : { pspg : subprogram receive; };
   end Driver_GRSPW_Protocol_thread_receiver.impl;

   -----------------
   -- SUBPROGRAMS --
   -----------------

   -- These subprograms model the high-level view of the SpaceWire
   -- protocol stack. They define an API used by the stack to send and
   -- receive data, and perform node's initialisation.

   subprogram Initialize

     -- Initialize the different internal resources for managing
     -- connections on a node. This subprogram has no formal visible
     -- parameters, but relies on well-known data structures and
     -- variables to configure the stack.

   properties
      Source_Name => "PolyORB_HI_Drivers_GRSPW.Initialize";
      Source_Language => (Ada);
   end Initialize;

   -------------

   subprogram Receive

      -- Receive data and dispatch them to the receiving entity. This
      -- program and its sibling (send) share a common protocol, not
      -- defined in the AADL model.

   properties
      Source_Name => "PolyORB_HI_Drivers_GRSPW.Receive";
      Source_Language => (Ada);
   end Receive;

   -------------

   subprogram Send

      -- Send data to a remote node. This program and its sibling
      -- (receive) share a common protocol, not defined in the AADL
      -- model.

   properties
      Source_Name => "PolyORB_HI_Drivers_GRSPW.Send";
      Source_Language => (Ada);
   end Send;

end GRSPW;
package GRUART

-- This package models a UART-based protocol layer for the
-- PolyORB-HI/Ada AADL runtime, based on the GRUART chipset from
-- AEROFlex Gaisler. It defines the subprograms and threads to be
-- integrated with the runtime low level interface.
--
-- To configure this interface, you should use the
-- Deployment::Configuration property with the following format:
--     "serial DEVICE BAUDS DATA_BITS PARITY STOP_BIT"
--
-- e.g.
--
--     uart : device GRUART::GRUART_Device
--            {Deployment::Configuration => "serial /dev/ttyS0 9600 8 N 1"
--

public

   with Deployment;
   with GR_CPCI_X4CV;
   with Generic_Bus;

   ------------
   -- DEVICE --
   ------------

   -- The main entrypoint for this package is this device, it relies
   -- on the 'Implement_As' feature that defines its full
   -- specification.

   device GRUART_Device
   features
      DB9_Wire : requires bus access Generic_Bus::Generic_Bus.impl;
      -- Connection to the remote node

   end GRUART_Device;

   device implementation GRUART_Device.impl
   properties
      Device_Driver =>
         classifier (GRUART::Driver_GRUART_Protocol.impl);
      Initialize_Entrypoint => classifier (GRUART::Initialize);
   end GRUART_Device.impl;

   ------------
   -- DRIVER --
   ------------

   -- In AADLv2, we can model the actual implementation of a driver
   -- using an abstract component.

   abstract Driver_GRUART_Protocol
   properties
      Deployment::Configuration_Type
        => classifier (ocarina_drivers::configuration_type_serial);
      Deployment::Version  => "0.1beta";
      Deployment::Help     => "Write your ASN.1 configuration here";
   end Driver_GRUART_Protocol;

   abstract implementation Driver_GRUART_Protocol.impl
   subcomponents
      receiver : thread Driver_GRUART_Protocol_thread_receiver.impl;
      sender : subprogram Send;
   end Driver_GRUART_Protocol.impl;

   -------------
   -- THREADS --
   -------------

   -- This thread handles the execution logic of the protocol
   -- stack. It relies on the previous subprograms to receive
   -- messages.

   thread Driver_GRUART_Protocol_thread_receiver

      -- This thread is dispatched when an event is detected on the
      -- real hardware. It then calls receive to handle the incoming
      -- event.

   properties
      Dispatch_Protocol => Background;
      Priority          => 10;
      source_stack_size => 200 KByte;
   end Driver_GRUART_Protocol_thread_receiver;

   thread implementation Driver_GRUART_Protocol_thread_receiver.impl
   calls
      call1 : { pspg : subprogram receive; };
   end Driver_GRUART_Protocol_thread_receiver.impl;

   -----------------
   -- SUBPROGRAMS --
   -----------------

   -- These subprograms model the high-level view of the SpaceWire
   -- protocol stack. They define an API used by the stack to send and
   -- receive data, and perform node's initialisation.

   subprogram Initialize

     -- Initialize the different internal resources for managing
     -- connections on a node. This subprogram has no formal visible
     -- parameters, but relies on well-known data structures and
     -- variables to configure the stack.

   properties
      Source_Name => "PolyORB_HI_Drivers_GRUART.Initialize";
      Source_Language => (Ada);
   end Initialize;

   -------------

   subprogram Receive

      -- Receive data and dispatch them to the receiving entity. This
      -- program and its sibling (send) share a common protocol, not
      -- defined in the AADL model.

   properties
      Source_Name => "PolyORB_HI_Drivers_GRUART.Receive";
      Source_Language => (Ada);
   end Receive;

   -------------

   subprogram Send

      -- Send data to a remote node. This program and its sibling
      -- (receive) share a common protocol, not defined in the AADL
      -- model.

   properties
      Source_Name => "PolyORB_HI_Drivers_GRUART.Send";
      Source_Language => (Ada);
   end Send;

end GRUART;
package ocarina_drivers_leon_eth

public

with Deployment;
with ocarina_buses;
with ocarina_drivers;

subprogram spg_leon_eth_poller
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_eth_leon_poller";
end spg_leon_eth_poller;


subprogram spg_leon_eth_sender
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_eth_leon_sender";
end spg_leon_eth_sender;

subprogram spg_leon_eth_init
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_eth_leon_init";
end spg_leon_eth_init;

thread thr_poller
end thr_poller;


thread implementation thr_poller.i
calls
        mycall : {
          pspg : subprogram spg_leon_eth_poller;
        };
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end thr_poller.i;

abstract eth_driver
properties
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_ip);
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end eth_driver;

abstract implementation eth_driver.leon
subcomponents
   sender                : subprogram spg_leon_eth_sender;
end eth_driver.leon;

abstract implementation eth_driver.leon_sender
subcomponents
   sender                : subprogram spg_leon_eth_sender;
end eth_driver.leon_sender;


end ocarina_drivers_leon_eth;
package ocarina_drivers_leon_serial

public

with Deployment;
with ocarina_buses;
with ocarina_drivers;

subprogram spg_serial_poller_leon
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_serial_leon_poller";
end spg_serial_poller_leon;


subprogram spg_serial_sender_leon
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_serial_leon_sender";
end spg_serial_sender_leon;

subprogram spg_serial_init_leon
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_serial_leon_init";
end spg_serial_init_leon;

subprogram spg_serial_init_leon_sender
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_serial_leon_init_sender";
end spg_serial_init_leon_sender;

thread serial_poller
end serial_poller;


thread implementation serial_poller.leon
calls
        mycall : {
          pspg : subprogram spg_serial_poller_leon;
        };
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end serial_poller.leon;

abstract serial_driver
properties
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_serial);
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end serial_driver;

abstract implementation serial_driver.leon
subcomponents
   receiver_leon_serial  : thread serial_poller.leon;
   sender                : subprogram spg_serial_sender_leon;
end serial_driver.leon;

abstract implementation serial_driver.leon_sender
subcomponents
   sender                : subprogram spg_serial_sender_leon;
end serial_driver.leon_sender;


end ocarina_drivers_leon_serial;
package Native_UART

-- This package models a UART protocol layer for the PolyORB-HI/Ada
-- AADL runtime. It defines the subprograms and threads to be
-- integrated with the runtime low level interface.
--
-- To configure this interface, you should use the
-- Deployment::Configuration property with the following format:
--     "serial DEVICE BAUDS DATA_BITS PARITY STOP_BIT"
--
-- e.g.
--
--     uart : device GRUART::GRUART_Device
--            {Deployment::Configuration => "serial /dev/ttyS0 9600 8 N 1"
--

public

   with Deployment;
   with Generic_Bus;

   ------------
   -- DEVICE --
   ------------

   -- The main entrypoint for this package is this device, it relies
   -- on the 'Implement_As' feature that defines its full
   -- specification.

   device Native_UART_Device
   features
      DB9_Wire : requires bus access Generic_Bus::Generic_Bus.impl;
      -- Connection to the remote node

   end Native_UART_Device;

   device implementation Native_UART_Device.impl
   properties
      Device_Driver =>
         classifier (Native_UART::Driver_Native_UART_Protocol.impl);
      Initialize_Entrypoint => classifier (Native_UART::Initialize);
   end Native_UART_Device.impl;

   ------------
   -- DRIVER --
   ------------

   -- In AADLv2, we can model the actual implementation of a driver
   -- using an abstract component.

   abstract Driver_Native_UART_Protocol
   properties
      Deployment::Configuration_Type
        => classifier (ocarina_drivers::configuration_type_serial);
      Deployment::Version  => "0.1beta";
      Deployment::Help     => "Write your ASN.1 configuration here";
   end Driver_Native_UART_Protocol;

   abstract implementation Driver_Native_UART_Protocol.impl
   subcomponents
      receiver : thread Driver_Native_UART_Protocol_thread_receiver.impl;
      sender : subprogram Send;
   end Driver_Native_UART_Protocol.impl;

   -------------
   -- THREADS --
   -------------

   -- This thread handles the execution logic of the protocol
   -- stack. It relies on the previous subprograms to receive
   -- messages.

   thread Driver_Native_UART_Protocol_thread_receiver

      -- This thread is dispatched when an event is detected on the
      -- real hardware. It then calls receive to handle the incoming
      -- event.

   properties
      Dispatch_Protocol => Background;
      Priority          => 10;
      source_stack_size => 200 KByte;
   end Driver_Native_UART_Protocol_thread_receiver;

   thread implementation Driver_Native_UART_Protocol_thread_receiver.impl
   calls
      call1 : { pspg : subprogram receive; };
   end Driver_Native_UART_Protocol_thread_receiver.impl;

   -----------------
   -- SUBPROGRAMS --
   -----------------

   -- These subprograms model the high-level view of the SpaceWire
   -- protocol stack. They define an API used by the stack to send and
   -- receive data, and perform node's initialisation.

   subprogram Initialize

     -- Initialize the different internal resources for managing
     -- connections on a node. This subprogram has no formal visible
     -- parameters, but relies on well-known data structures and
     -- variables to configure the stack.

   properties
      Source_Name => "PolyORB_HI_Drivers_Native_UART.Initialize";
      Source_Language => (Ada);
   end Initialize;

   -------------

   subprogram Receive

      -- Receive data and dispatch them to the receiving entity. This
      -- program and its sibling (send) share a common protocol, not
      -- defined in the AADL model.

   properties
      Source_Name => "PolyORB_HI_Drivers_Native_UART.Receive";
      Source_Language => (Ada);
   end Receive;

   -------------

   subprogram Send

      -- Send data to a remote node. This program and its sibling
      -- (receive) share a common protocol, not defined in the AADL
      -- model.

   properties
      Source_Name => "PolyORB_HI_Drivers_Native_UART.Send";
      Source_Language => (Ada);
   end Send;

end Native_UART;
package ocarina_drivers_rasta_1553

public
with Deployment;

subprogram spg_1553_controller_rasta
properties
        Source_Language   => (C);
        Source_Name       => "__po_hi_c_driver_1553_rasta_controller";
end spg_1553_controller_rasta;

subprogram spg_1553_poller_rasta_terminal
properties
        Source_Language   => (C);
        Source_Name       => "__po_hi_c_driver_1553_rasta_terminal_poller";
end spg_1553_poller_rasta_terminal;

subprogram spg_1553_sender_rasta_controller
properties
        Source_Language   => (C);
        Source_Name       => "__po_hi_c_driver_1553_rasta_sender_controller";
end spg_1553_sender_rasta_controller;

subprogram spg_1553_sender_rasta_terminal
properties
        Source_Language   => (C);
        Source_Name       => "__po_hi_c_driver_1553_rasta_sender_terminal";
end spg_1553_sender_rasta_terminal;


subprogram spg_1553_init_rasta_controller
properties
        Source_Language   => (C);
        Source_Name       => "__po_hi_c_driver_1553_rasta_init_controller";
end spg_1553_init_rasta_controller;


subprogram spg_1553_init_rasta_terminal
properties
        Source_Language   => (C);
        Source_Name       => "__po_hi_c_driver_1553_rasta_init_terminal";
end spg_1553_init_rasta_terminal;



thread if1553_poller
end if1553_poller;

thread implementation if1553_poller.rasta_terminal
calls
        mycall : {
          pspg : subprogram spg_1553_poller_rasta_terminal;
        };
properties
   Period => 2000ms;
   Dispatch_Protocol => Periodic;
end if1553_poller.rasta_terminal;

thread if1553_controller
end if1553_controller;

thread implementation if1553_controller.rasta
calls
        mycall : {
          pspg : subprogram spg_1553_controller_rasta;
        };
properties
   Period => 4000ms;
   Dispatch_Protocol => Periodic;
end if1553_controller.rasta;



abstract if1553_driver
properties
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end if1553_driver;

abstract implementation if1553_driver.rasta_terminal
subcomponents
   receiver_rasta_1553 : thread       if1553_poller.rasta_terminal;
   sender              : subprogram   spg_1553_sender_rasta_terminal;
end if1553_driver.rasta_terminal;

abstract implementation if1553_driver.rasta_controller_sender_only
subcomponents
--   controller  : thread       if1553_controller.rasta;
--   This thread (controller) should be a poller thread that
--   gives orders to the terminal nodes to send/receive data.
--   It should also specify the communication policy (when a terminal
--   is authorized to send/receive data).

--   We don't specify poller and receiver since this controller
--   is just a node that sends data to a single other node.

   sender      : subprogram   spg_1553_sender_rasta_controller;
end if1553_driver.rasta_controller_sender_only;


end ocarina_drivers_rasta_1553;
package ocarina_drivers_rasta_serial

public

with Deployment;
with ocarina_buses;
with ocarina_drivers;

subprogram spg_serial_poller_rasta
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_serial_rasta_poller";
end spg_serial_poller_rasta;


subprogram spg_serial_sender_rasta
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_serial_rasta_sender";
end spg_serial_sender_rasta;




subprogram spg_serial_init_rasta
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_serial_rasta_init";
end spg_serial_init_rasta;


thread serial_poller
end serial_poller;


thread implementation serial_poller.rasta
calls
        mycall : {
          pspg : subprogram spg_serial_poller_rasta;
        };
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end serial_poller.rasta;

abstract serial_driver
properties
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_serial);
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end serial_driver;

abstract implementation serial_driver.rasta
subcomponents
   receiver_rasta_serial : thread serial_poller.rasta;
   sender                : subprogram spg_serial_sender_rasta;
end serial_driver.rasta;

end ocarina_drivers_rasta_serial;
package ocarina_drivers_rasta_spacewire

public

with ocarina_buses;
with Deployment;

subprogram spg_spacewire_poller_rasta
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_spacewire_rasta_poller";
end spg_spacewire_poller_rasta;

subprogram spg_spacewire_sender_rasta
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_spacewire_rasta_sender";
end spg_spacewire_sender_rasta;

subprogram spg_spacewire_init_rasta
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_spacewire_rasta_init";
end spg_spacewire_init_rasta;


thread spacewire_poller
end spacewire_poller;

thread implementation spacewire_poller.rasta
calls
        mycall : {
          pspg : subprogram spg_spacewire_poller_rasta;
        };
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end spacewire_poller.rasta;


abstract spacewire_driver
properties
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_spacewire);
end spacewire_driver;

abstract implementation spacewire_driver.rasta
subcomponents
   receiver_rasta_spacewire : thread spacewire_poller.rasta;
   sender                   : subprogram spg_spacewire_sender_rasta;
end spacewire_driver.rasta;

end ocarina_drivers_rasta_spacewire;
package ocarina_drivers_scoc3_spacewire

public

with ocarina_buses;
with Deployment;

subprogram spg_poller
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_spacewire_scoc3_poller";
end spg_poller;

subprogram spg_sender
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_spacewire_scoc3_sender";
end spg_sender;

subprogram spg_init
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_spacewire_scoc3_init";
end spg_init;


thread thr_poller
end thr_poller;

thread implementation thr_poller.i
calls
        mycall : {
          pspg : subprogram spg_poller;
        };
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end thr_poller.i;


abstract driver
properties
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Check the ASN.1 type definition";
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_spacewire);
end driver;

abstract implementation driver.i
subcomponents
   receiver_rasta_spacewire : thread thr_poller.i;
   sender                   : subprogram spg_sender;
end driver.i;

end ocarina_drivers_scoc3_spacewire;
package STM32F4_UART

-- To configure this interface, you should use the
-- Deployment::Configuration property with the following format:
--     "serial DEVICE BAUDS DATA_BITS PARITY STOP_BIT"

public

   with Deployment;
   with Generic_Bus;

   ------------
   -- DRIVER --
   ------------

   -- In AADLv2, we can model the actual implementation of a driver
   -- using an abstract component.

   abstract driver
   properties
      Deployment::Configuration_Type
        => classifier (ocarina_drivers::configuration_type_serial);
      Deployment::Version  => "0.1beta";
      Deployment::Help     => "Write your ASN.1 configuration here";
   end driver;

   abstract implementation driver.STM32F4_UART
   subcomponents
      receiver : thread Driver_STM32F4_UART_Protocol_thread_receiver.impl;
      sender : subprogram Send;
   end driver.STM32F4_UART;

   -------------
   -- THREADS --
   -------------

   -- This thread handles the execution logic of the protocol
   -- stack. It relies on the previous subprograms to receive
   -- messages.

   thread Driver_STM32F4_UART_Protocol_thread_receiver

      -- This thread is dispatched when an event is detected on the
      -- real hardware. It then calls receive to handle the incoming
      -- event.

   properties
      Dispatch_Protocol => Background;
      Priority          => 10;
      source_stack_size => 10 KByte;
   end Driver_STM32F4_UART_Protocol_thread_receiver;

   thread implementation Driver_STM32F4_UART_Protocol_thread_receiver.impl
   calls
      call1 : { pspg : subprogram receive; };
   end Driver_STM32F4_UART_Protocol_thread_receiver.impl;

   -----------------
   -- SUBPROGRAMS --
   -----------------

   -- These subprograms model the high-level view of the SpaceWire
   -- protocol stack. They define an API used by the stack to send and
   -- receive data, and perform node's initialisation.

   subprogram Initialize

     -- Initialize the different internal resources for managing
     -- connections on a node. This subprogram has no formal visible
     -- parameters, but relies on well-known data structures and
     -- variables to configure the stack.

   properties
      Source_Name => "PolyORB_HI_Drivers_STM32F4_UART.Initialize";
      Source_Language => (Ada);
   end Initialize;

   -------------

   subprogram Receive

      -- Receive data and dispatch them to the receiving entity. This
      -- program and its sibling (send) share a common protocol, not
      -- defined in the AADL model.

   properties
      Source_Name => "PolyORB_HI_Drivers_STM32F4_UART.Receive";
      Source_Language => (Ada);
   end Receive;

   -------------

   subprogram Send

      -- Send data to a remote node. This program and its sibling
      -- (receive) share a common protocol, not defined in the AADL
      -- model.

   properties
      Source_Name => "PolyORB_HI_Drivers_STM32F4_UART.Send";
      Source_Language => (Ada);
   end Send;

end STM32F4_UART;
package Crazyflie_BLE

-- To configure this interface, you should use the
-- Deployment::Configuration property with the following format:
--     "bluetooth CHANNEL DATARATE ADDRESS"

public

   with Deployment;
   with Generic_Bus;

   ------------
   -- DRIVER --
   ------------

   -- In AADLv2, we can model the actual implementation of a driver
   -- using an abstract component.

   abstract driver
   properties
      Deployment::Configuration_Type
        => classifier (ocarina_drivers::configuration_type_bluetooth);
      Deployment::Version  => "0.1beta";
      Deployment::Help     => "Write your ASN.1 configuration here";
   end driver;

   abstract implementation driver.Crazyflie_BLE
   subcomponents
      receiver : thread Driver_Crazyflie_BLE_Protocol_thread_receiver.impl;
      sender : subprogram Send;
   end driver.Crazyflie_BLE;

   -------------
   -- THREADS --
   -------------

   -- This thread handles the execution logic of the protocol
   -- stack. It relies on the previous subprograms to receive
   -- messages.

   thread Driver_Crazyflie_BLE_Protocol_thread_receiver

      -- This thread is dispatched when an event is detected on the
      -- real hardware. It then calls receive to handle the incoming
      -- event.

   properties
      Dispatch_Protocol => Background;
      Priority          => 10;
      source_stack_size => 10 KByte;
   end Driver_Crazyflie_BLE_Protocol_thread_receiver;

   thread implementation Driver_Crazyflie_BLE_Protocol_thread_receiver.impl
   calls
      call1 : { pspg : subprogram receive; };
   end Driver_Crazyflie_BLE_Protocol_thread_receiver.impl;

   -----------------
   -- SUBPROGRAMS --
   -----------------

   -- These subprograms model the high-level view of the SpaceWire
   -- protocol stack. They define an API used by the stack to send and
   -- receive data, and perform node's initialisation.

   subprogram Initialize

     -- Initialize the different internal resources for managing
     -- connections on a node. This subprogram has no formal visible
     -- parameters, but relies on well-known data structures and
     -- variables to configure the stack.

   properties
      Source_Name => "PolyORB_HI_Drivers_Crazyflie_BLE.Initialize";
      Source_Language => (Ada);
   end Initialize;

   -------------

   subprogram Receive

      -- Receive data and dispatch them to the receiving entity. This
      -- program and its sibling (send) share a common protocol, not
      -- defined in the AADL model.

   properties
      Source_Name => "PolyORB_HI_Drivers_Crazyflie_BLE.Receive";
      Source_Language => (Ada);
   end Receive;

   -------------

   subprogram Send

      -- Send data to a remote node. This program and its sibling
      -- (receive) share a common protocol, not defined in the AADL
      -- model.

   properties
      Source_Name => "PolyORB_HI_Drivers_Crazyflie_BLE.Send";
      Source_Language => (Ada);
   end Send;

end Crazyflie_BLE;
package Client_BLE

-- To configure this interface, you should use the
-- Deployment::Configuration property with the following format:
--     "bluetooth CHANNEL DATARATE ADDRESS"

public

   with Deployment;
   with Generic_Bus;

   ------------
   -- DRIVER --
   ------------

   -- In AADLv2, we can model the actual implementation of a driver
   -- using an abstract component.

   abstract driver
   properties
      Deployment::Configuration_Type
        => classifier (ocarina_drivers::configuration_type_bluetooth);
      Deployment::Version  => "0.1beta";
      Deployment::Help     => "Write your ASN.1 configuration here";
   end driver;

   abstract implementation driver.Client_BLE
   subcomponents
      receiver : thread Driver_Client_BLE_Protocol_thread_receiver.impl;
      sender : subprogram Send;
   end driver.Client_BLE;

   -------------
   -- THREADS --
   -------------

   -- This thread handles the execution logic of the protocol
   -- stack. It relies on the previous subprograms to receive
   -- messages.

   thread Driver_Client_BLE_Protocol_thread_receiver

      -- This thread is dispatched when an event is detected on the
      -- real hardware. It then calls receive to handle the incoming
      -- event.

   properties
      Dispatch_Protocol => Background;
      Priority          => 10;
      source_stack_size => 100 KByte;
   end Driver_Client_BLE_Protocol_thread_receiver;

   thread implementation Driver_Client_BLE_Protocol_thread_receiver.impl
   calls
      call1 : { pspg : subprogram receive; };
   end Driver_Client_BLE_Protocol_thread_receiver.impl;

   -----------------
   -- SUBPROGRAMS --
   -----------------

   -- These subprograms model the high-level view of the SpaceWire
   -- protocol stack. They define an API used by the stack to send and
   -- receive data, and perform node's initialisation.

   subprogram Initialize

     -- Initialize the different internal resources for managing
     -- connections on a node. This subprogram has no formal visible
     -- parameters, but relies on well-known data structures and
     -- variables to configure the stack.

   properties
      Source_Name => "PolyORB_HI_Drivers_Client_BLE.Initialize";
      Source_Language => (Ada);
   end Initialize;

   -------------

   subprogram Receive

      -- Receive data and dispatch them to the receiving entity. This
      -- program and its sibling (send) share a common protocol, not
      -- defined in the AADL model.

   properties
      Source_Name => "PolyORB_HI_Drivers_Client_BLE.Receive";
      Source_Language => (Ada);
   end Receive;

   -------------

   subprogram Send

      -- Send data to a remote node. This program and its sibling
      -- (receive) share a common protocol, not defined in the AADL
      -- model.

   properties
      Source_Name => "PolyORB_HI_Drivers_Client_BLE.Send";
      Source_Language => (Ada);
   end Send;

end Client_BLE;
package ocarina_drivers_star_dundee_spacewire_brick
public

with ocarina_buses;
with Deployment;

subprogram spg_poller
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_spw_usb_brick_poller";
end spg_poller;

subprogram spg_sender
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_spw_usb_brick_sender";
end spg_sender;

subprogram spg_init
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_spw_usb_brick_init";
end spg_init;


thread thr_poller
end thr_poller;

thread implementation thr_poller.i
calls
        mycall : {
          pspg : subprogram spg_poller;
        };
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end thr_poller.i;


abstract driver
properties
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_spacewire);
end driver;

abstract implementation driver.usb_brick
subcomponents
   receiver_rasta_spacewire : thread thr_poller.i;
   sender                   : subprogram spg_sender;
end driver.usb_brick;

end ocarina_drivers_star_dundee_spacewire_brick;
package ocarina_drivers_serial

public

with Deployment;
with ocarina_drivers;

subprogram spg_serial_poller_linux
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_serial_linux_poller";
end spg_serial_poller_linux;


subprogram spg_serial_sender_linux
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_serial_linux_sender";
end spg_serial_sender_linux;


subprogram spg_serial_init_linux
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_serial_linux_init";
end spg_serial_init_linux;

subprogram spg_serial_init_linux_sender
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_serial_linux_init_sender";
end spg_serial_init_linux_sender;

subprogram spg_serial_init_linux_receiver
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_serial_linux_init_receiver";
end spg_serial_init_linux_receiver;

thread serial_poller
end serial_poller;

thread implementation serial_poller.linux
calls
        mycall : {
          pspg : subprogram spg_serial_poller_linux;
        };
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end serial_poller.linux;


abstract serial_driver
properties
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_serial);
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end serial_driver;

abstract implementation serial_driver.linux
subcomponents
   serial_linux_receiver : thread serial_poller.linux;
   sender                : subprogram spg_serial_sender_linux;
end serial_driver.linux;

abstract implementation serial_driver.linux_sender
subcomponents
   sender                : subprogram spg_serial_sender_linux;
end serial_driver.linux_sender;


abstract implementation serial_driver.linux_receiver
subcomponents
   serial_linux_receiver : thread serial_poller.linux;
end serial_driver.linux_receiver;

end ocarina_drivers_serial;
package ocarina_drivers_ip_pohic

public
with Deployment;
with ocarina_drivers;

subprogram spg_sockets_init
properties
        Source_Language   => (C);
        Source_Name       => "__po_hi_driver_sockets_init";
end spg_sockets_init;


subprogram spg_eth_linux_sender
properties
        Source_Language   => (C);
        Source_Name       => "__po_hi_driver_sockets_send";
end spg_eth_linux_sender;

subprogram implementation spg_eth_linux_sender.i
end spg_eth_linux_sender.i;

abstract sockets_impl
properties
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_ip);
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end sockets_impl;

abstract implementation sockets_impl.i
subcomponents
   sender   : subprogram   spg_eth_linux_sender.i;
end sockets_impl.i;

end ocarina_drivers_ip_pohic;
package ocarina_drivers_rtems_ne2000

public

with Deployment;

subprogram init
properties
        Source_Language   => (C);
        Source_Name       => "__po_hi_driver_rtems_ne2000_init";
end init;

thread poller
end poller;

thread implementation poller.i
calls
        mycall : {
          pspg : subprogram spg_poller;
        };
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end poller.i;


subprogram spg_poller
properties
        Source_Language   => (C);
        Source_Name       => "__po_hi_driver_rtems_ne2000_poller";
end spg_poller;


subprogram spg_sender
properties
        Source_Language   => (C);
        Source_Name       => "__po_hi_driver_sockets_send";
end spg_sender;


abstract driver
properties
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end driver;


abstract implementation driver.i
subcomponents
--  receiver : thread       eth_sockets_ne2000_rtems_poller.i;
   sender   : subprogram   spg_sender;
end driver.i;

end ocarina_drivers_rtems_ne2000;
package TCP_IP_Protocol

-- This package models a TCP/IP based protocol layer for the
-- PolyORB-HI/Ada AADL runtime. It defines the subprograms and threads
-- to be integrated with the runtime low level interface.
--
-- To configure this interface, you should use the
-- Deployment::Configuration property with the following format:
--     "ip <ipv4_addresse> <ipv4_port>"
--
-- e.g.
--
--     netif : device TCP_IP_Protocol::TCP_IP_Device
--            {Deployment::Configuration => "ip 192.168.0.10 45678";}:

public

   with Generic_Bus;
   with Deployment;

   ------------
   -- DEVICE --
   ------------

   -- The main entrypoint for this package is this device, it relies
   -- on the 'Implement_As' feature that defines its full
   -- specification.

   device TCP_IP_Device
   features
      Ethernet_Wire : requires bus access Generic_Bus::Generic_Bus.impl;
      -- Connection to the remote node

   end TCP_IP_Device;

   device implementation TCP_IP_Device.impl
   properties
      Device_Driver =>
         classifier (TCP_IP_Protocol::Driver_TCP_IP_Protocol.impl);
      Initialize_Entrypoint => classifier (TCP_IP_Protocol::Initialize);
   end TCP_IP_Device.impl;

   ------------
   -- DRIVER --
   ------------

   -- In AADLv2, we can model the actual implementation of a driver
   -- using an abstract component.

   abstract Driver_TCP_IP_Protocol
   properties
      Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_ip);
      Deployment::Version  => "0.1beta";
      Deployment::Help     => "Write your ASN.1 configuration here";
   end Driver_TCP_IP_Protocol;

   abstract implementation Driver_TCP_IP_Protocol.impl
   subcomponents
      receiver : thread Driver_TCP_IP_Protocol_thread_receiver.impl;
      sender : subprogram Send;
   end Driver_TCP_IP_Protocol.impl;

   -------------
   -- THREADS --
   -------------

   -- This thread handles the execution logic of the protocol
   -- stack. It relies on the previous subprograms to receive
   -- messages.

   thread Driver_TCP_IP_Protocol_thread_receiver

      -- This thread is dispatched when an event is detected on the
      -- real hardware. It then calls receive to handle the incoming
      -- event.

   properties
      -- Initialize_Entrypoint
      --    => classifier (TCP_IP_Protocol::Initialize_Receiver);
      Dispatch_Protocol => Background;
   end Driver_TCP_IP_Protocol_thread_receiver;

   thread implementation Driver_TCP_IP_Protocol_thread_receiver.impl
   calls
      call1 : { pspg : subprogram receive; };
   end Driver_TCP_IP_Protocol_thread_receiver.impl;

   -----------------
   -- SUBPROGRAMS --
   -----------------

   -- These subprograms model the high-level view of the TCP/IP
   -- protocol stack. They define an API used by the stack to send and
   -- receive data, and perform node's initialisation.

   subprogram Initialize

     -- Initialize the different internal resources for managing
     -- connections on a node. This subprogram has no formal visible
     -- parameters, but relies on well-known data structures and
     -- variables to configure the stack.

   properties
      Source_Name => "POlyORB_HI_Drivers_Native_TCP_IP.Initialize";
      Source_Language => (Ada);
   end Initialize;

   -------------

   subprogram Initialize_Receiver

     -- Initialize the receiver thread

   properties
      Source_Name => "POlyORB_HI_Drivers_Native_TCP_IP.Initialize_Receiver";
      Source_Language => (Ada);
   end Initialize_Receiver;

   -------------

   subprogram Receive

      -- Receive data and dispatch them to the receiving entity. This
      -- program and its sibling (send) share a common protocol, not
      -- defined in the AADL model.

   properties
      Source_Name => "POlyORB_HI_Drivers_Native_TCP_IP.Receive";
      Source_Language => (Ada);
   end Receive;

   -------------

   subprogram Send

      -- Send data to a remote node. This program and its sibling
      -- (receive) share a common protocol, not defined in the AADL
      -- model.

   properties
      Source_Name => "POlyORB_HI_Drivers_Native_TCP_IP.Send";
      Source_Language => (Ada);
   end Send;

end TCP_IP_Protocol;
package ocarina_drivers_udp_exarm

public

with Data_Model;
with Base_Types;

data protocol
properties
   Data_Model::Data_Representation => Struct;
end protocol;

data implementation protocol.robot
subcomponents
   cmd   : data Base_Types::Unsigned_32;
   pktid : data Base_Types::Unsigned_32;
   X1    : data Base_Types::Float_32;
   X2    : data Base_Types::Float_32;
   X3    : data Base_Types::Float_32;
   Y1    : data Base_Types::Float_32;
   Y2    : data Base_Types::Float_32;
   Y3    : data Base_Types::Float_32;
   Z1    : data Base_Types::Float_32;
   Z2    : data Base_Types::Float_32;
   Z3    : data Base_Types::Float_32;
   P1    : data Base_Types::Float_32;
   P2    : data Base_Types::Float_32;
   P3    : data Base_Types::Float_32;
   J1    : data Base_Types::Float_32;
   J2    : data Base_Types::Float_32;
   J3    : data Base_Types::Float_32;
   J4    : data Base_Types::Float_32;
   J5    : data Base_Types::Float_32;
   J6    : data Base_Types::Float_32;
   J7    : data Base_Types::Float_32;
   Elbow : data Base_Types::Float_32;
end protocol.robot;


data implementation protocol.vr
subcomponents
   J1    : data Base_Types::Float_64;
   J2    : data Base_Types::Float_64;
   J3    : data Base_Types::Float_64;
   J4    : data Base_Types::Float_64;
   J5    : data Base_Types::Float_64;
   J6    : data Base_Types::Float_64;
   J7    : data Base_Types::Float_64;
   J8    : data Base_Types::Float_64;
   J9    : data Base_Types::Float_64;
   J10    : data Base_Types::Float_64;
   J11    : data Base_Types::Float_64;
   J12    : data Base_Types::Float_64;
   J13    : data Base_Types::Float_64;
   J14    : data Base_Types::Float_64;
   J15    : data Base_Types::Float_64;
   J16    : data Base_Types::Float_64;
   P1    : data Base_Types::Float_64;
   P2    : data Base_Types::Float_64;
   P3    : data Base_Types::Float_64;
   X1    : data Base_Types::Float_64;
   X2    : data Base_Types::Float_64;
   X3    : data Base_Types::Float_64;
   Y1    : data Base_Types::Float_64;
   Y2    : data Base_Types::Float_64;
   Y3    : data Base_Types::Float_64;
   Z1    : data Base_Types::Float_64;
   Z2    : data Base_Types::Float_64;
   Z3    : data Base_Types::Float_64;
end protocol.vr;


subprogram init
properties
   Source_Language   => (C);
   Source_Name       => "__po_hi_driver_exarm_init";
end init;

subprogram spg_sender
properties
   Source_Language   => (C);
   Source_Name       => "__po_hi_driver_exarm_send";
end spg_sender;

abstract driver
end driver;

abstract implementation driver.i
subcomponents
   sender : subprogram spg_sender;
end driver.i;

end ocarina_drivers_udp_exarm;
package ocarina_processors_arm

public

with Deployment;
with Cheddar_Properties;

processor arm
end arm;

processor crazyflie_v2 extends arm
properties
   Deployment::Execution_Platform => GNAT_Runtime;
   Deployment::Ada_Runtime => "crazyflie_full";
end crazyflie_v2;

processor implementation crazyflie_v2.gnat
properties
   Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
   Priority_Range => 0 .. 255;
   Cheddar_Properties::Scheduler_Quantum => 0 Ms;
   Cheddar_Properties::Preemptive_Scheduler => true;
end crazyflie_v2.gnat;


processor stm32f407_discovery extends arm
properties
   Deployment::Execution_Platform => GNAT_Runtime;
   Deployment::Ada_Runtime => "stm32f407_discovery_full";
end stm32f407_discovery;

processor implementation stm32f407_discovery.gnat2017
properties
   Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
   Priority_Range => 0 .. 255;
   Cheddar_Properties::Scheduler_Quantum => 0 Ms;
   Cheddar_Properties::Preemptive_Scheduler => true;
end stm32f407_discovery.gnat2017;

processor stm32f429_discovery extends arm
properties
   Deployment::Execution_Platform => GNAT_Runtime;
   Deployment::Ada_Runtime => "stm32f429_discovery_full";
end stm32f429_discovery;

processor implementation stm32f429_discovery.gnat2017
properties
   Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
   Priority_Range => 0 .. 255;
   Cheddar_Properties::Scheduler_Quantum => 0 Ms;
   Cheddar_Properties::Preemptive_Scheduler => true;
end stm32f429_discovery.gnat2017;



processor nds extends arm
end nds;

--   processor implementation nds.rtems
--   properties
--      Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
--      Priority_Range => 0 .. 255;
--      Cheddar_Properties::Scheduler_Quantum => 0 Ms;
--      Cheddar_Properties::Preemptive_Scheduler => true;
--      Deployment::Execution_Platform => NDS_RTEMS;
--   end nds.rtems;


processor gumstix extends arm
end gumstix;

--   processor implementation gumstix.rtems
--   properties
--      Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
--      Priority_Range => 0 .. 255;
--      Cheddar_Properties::Scheduler_Quantum => 0 Ms;
--      Cheddar_Properties::Preemptive_Scheduler => true;
--      Deployment::Execution_Platform => GUMSTIX_RTEMS;
--   end gumstix.rtems;

end ocarina_processors_arm;
package ocarina_processors_leon
public

with Deployment;

processor leon
end leon;

processor leon2 extends leon
end leon2;

processor leon3 extends leon
end leon3;

processor gr712rc extends leon
end gr712rc;

processor n2x extends leon
end n2x;

processor gr740 extends leon
end gr740;

processor implementation leon3.AIR
properties
   Deployment::Execution_Platform => AIR;
end leon3.AIR;

-- RTEMS mainline targets

processor implementation leon3.rtems51_posix
properties
   Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
   Priority_Range => 0 .. 255;
   Scheduler_Quantum => 0 Ms;
   Preemptive_Scheduler => true;
   Deployment::Execution_Platform => LEON_RTEMS_POSIX;
   EnvVars => "RTEMS_MAKEFILE_PATH_LEON=/opt/rtems-5.1-2018.03.08/sparc-rtems5/leon3";
end leon3.rtems51_posix;

processor implementation n2x.rtems51_posix
properties
   Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
   Priority_Range => 0 .. 255;
   Scheduler_Quantum => 0 Ms;
   Preemptive_Scheduler => true;
   Deployment::Execution_Platform => LEON_RTEMS_POSIX;
   EnvVars => "RTEMS_MAKEFILE_PATH_LEON=/opt/rtems-5.1-2018.03.08/sparc-rtems5/leon3:CFLAGS=-DCONFIGURE_SMP_APPLICATION -DCONFIGURE_MAXIMUM_PROCESSORS=4 ";
end n2x.rtems51_posix;

processor implementation gr712rc.rtems51_posix
properties
   Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
   Priority_Range => 0 .. 255;
   Scheduler_Quantum => 0 Ms;
   Preemptive_Scheduler => true;
   Deployment::Execution_Platform => LEON_RTEMS_POSIX;
   EnvVars => "RTEMS_MAKEFILE_PATH_LEON=/opt/rtems-5.1-2018.03.08/sparc-rtems5/gr712rc:CFLAGS=-DCONFIGURE_SMP_APPLICATION -DCONFIGURE_MAXIMUM_PROCESSORS=2 ";
end gr712rc.rtems51_posix;

processor implementation gr740.rtems51_posix
properties
   Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
   Priority_Range => 0 .. 255;
   Scheduler_Quantum => 0 Ms;
   Preemptive_Scheduler => true;
   Deployment::Execution_Platform => LEON_RTEMS_POSIX;
   EnvVars => "RTEMS_MAKEFILE_PATH_LEON=/opt/rtems-5.1-2018.03.08/sparc-rtems5/gr740:CFLAGS=-DCONFIGURE_SMP_APPLICATION -DCONFIGURE_MAXIMUM_PROCESSORS=4 ";
end gr740.rtems51_posix;

-- GAISLER targets

processor implementation leon3.rcc13rc4_posix
properties
   Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
   Priority_Range => 0 .. 255;
   Scheduler_Quantum => 0 Ms;
   Preemptive_Scheduler => true;
   Deployment::Execution_Platform => LEON_RTEMS_POSIX;
   EnvVars => "RTEMS_MAKEFILE_PATH_LEON=/opt/rcc-1.3-rc4/sparc-gaisler-rtems5/leon3";
end leon3.rcc13rc4_posix;

processor implementation gr712rc.rcc13rc4_posix
properties
   Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
   Priority_Range => 0 .. 255;
   Scheduler_Quantum => 0 Ms;
   Preemptive_Scheduler => true;
   Deployment::Execution_Platform => LEON_RTEMS_POSIX;
   EnvVars => "RTEMS_MAKEFILE_PATH_LEON=/opt/rcc-1.3-rc4/sparc-gaisler-rtems5/gr712rc_smp:CFLAGS=-DCONFIGURE_SMP_APPLICATION -DCONFIGURE_MAXIMUM_PROCESSORS=2 ";
end gr712rc.rcc13rc4_posix;

processor implementation n2x.rcc13rc4_posix
properties
   Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
   Priority_Range => 0 .. 255;
   Scheduler_Quantum => 0 Ms;
   Preemptive_Scheduler => true;
   Deployment::Execution_Platform => LEON_RTEMS_POSIX;
   EnvVars => "RTEMS_MAKEFILE_PATH_LEON=/opt/rcc-1.3-rc4/sparc-gaisler-rtems5/leon3_smp:CFLAGS=-DCONFIGURE_SMP_APPLICATION -DCONFIGURE_MAXIMUM_PROCESSORS=4 ";
end n2x.rcc13rc4_posix;

processor implementation gr740.rcc13rc4_posix
properties
   Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
   Priority_Range => 0 .. 255;
   Scheduler_Quantum => 0 Ms;
   Preemptive_Scheduler => true;
   Deployment::Execution_Platform => LEON_RTEMS_POSIX;
   EnvVars => "RTEMS_MAKEFILE_PATH_LEON=/opt/rcc-1.3-rc4/sparc-gaisler-rtems5/gr740_smp:CFLAGS=-DCONFIGURE_SMP_APPLICATION -DCONFIGURE_MAXIMUM_PROCESSORS=4 ";
end gr740.rcc13rc4_posix;

--   processor implementation leon.ork
--   properties
--      Deployment::Execution_Platform => LEON_ORK;
--   end leon.ork;

virtual processor xtratum_partition
end xtratum_partition;

virtual processor implementation xtratum_partition.generic
end xtratum_partition.generic;

--   processor implementation leon3.scoc3
--   properties
--      Deployment::Execution_Platform => LEON3_SCOC3;
--   end leon3.scoc3;

--   processor implementation leon3.xtratum
--   properties
--      Deployment::Execution_Platform => LEON3_XTRATUM;
--   end leon3.xtratum;

--   processor implementation leon3.xtratum_2partitions extends leon3.xtratum
--   subcomponents
--           part1 : virtual processor xtratum_partition.generic
--         { Deployment::Execution_Platform => LEON3_XM3;};
--           part2 : virtual processor xtratum_partition.generic
--         { Deployment::Execution_Platform => LEON3_XM3;};
     --  properties
     --   ARINC653::Partition_Slots => (500ms, 500ms);
     --   ARINC653::Slots_Allocation => (reference (part1), reference (part2));
     --	ARINC653::Module_Major_Frame => 1000ms;
--   end leon3.xtratum_2partitions;

end ocarina_processors_leon;
package ocarina_processors_x86

public

with Deployment;

processor x86
properties
   Scheduling_Protocol => (POSIX_1003_HIGHEST_PRIORITY_FIRST_PROTOCOL);
   Deployment::Execution_Platform => Native;
end x86;

processor implementation x86.linux
properties
   Deployment::Execution_Platform => Native;
end x86.linux;

processor implementation x86.linux_dll
properties
   Deployment::Execution_Platform => Linux_DLL;
end x86.linux_dll;

processor implementation x86.win32
properties
   Deployment::Execution_Platform => win32;
end x86.win32;


--   processor implementation x86.linux_bench
--   properties
--      Scheduling_Protocol => (POSIX_1003_HIGHEST_PRIORITY_FIRST_PROTOCOL);
--      Deployment::Execution_Platform => bench;
--   end x86.linux_bench;

--   processor implementation x86.linux32
--   properties
--      Deployment::Execution_Platform => Linux32;
--   end x86.linux32;
--
--   processor implementation x86.linux64
--   properties
--      Deployment::Execution_Platform => Linux64;
--   end x86.linux64;

--   processor implementation x86.native
--   properties
--      Deployment::Execution_Platform => Native;
--   end x86.native;
--
--   processor implementation x86.native_compcert
--   properties
--      Deployment::Execution_Platform => Native_Compcert;
--   end x86.native_compcert;
--
--   processor implementation x86.rtems
--   properties
--      Deployment::Execution_Platform => X86_RTEMS;
--   end x86.rtems;
--
--   processor implementation x86.rtems_posix
--   properties
--      Deployment::Execution_Platform => X86_RTEMS_POSIX;
--   end x86.rtems_posix;

--   processor implementation x86.xenomai_posix
--   properties
--      Deployment::Execution_Platform => linux32_xenomai_posix;
--   end x86.xenomai_posix;
--
--   processor implementation x86.xenomai_native
--   properties
--      Deployment::Execution_Platform => linux32_xenomai_native;
--   end x86.xenomai_native;

end ocarina_processors_x86;
package ocarina_drivers_grspw_packet
public

  -- This driver works for RTEMS 5 (presumably RTEMS 4.11) based on
  -- drvmgr driver subsystem, using GRSPW Packet driver.
  --
  -- See Chapter 18 of RCC 1.3 manual

  with ocarina_buses;
  with Deployment;

  subprogram spg_grspw_packet_poller_rasta
  properties
    Source_Language => (C);
    Source_Name => "__po_hi_c_driver_drvmgr_grspw_poller";
    Source_Text => ("grspw_api.c", "spwrouter_custom_config.c",
    "po_hi_driver_drvmgr_common.c", "grspw_pkt_lib.c",
    "po_hi_driver_rtems_drvmgr_spacewire.c");
  end spg_grspw_packet_poller_rasta;

  subprogram spg_grspw_packet_sender_rasta
  properties
    Source_Language => (C);
    Source_Name => "__po_hi_c_driver_drvmgr_grspw_sender";
    Source_Text => ("grspw_api.c", "spwrouter_custom_config.c",
    "po_hi_driver_drvmgr_common.c", "grspw_pkt_lib.c",
    "po_hi_driver_rtems_drvmgr_spacewire.c");
  end spg_grspw_packet_sender_rasta;

  subprogram spg_grspw_packet_init_rasta
  properties
    Source_Language => (C);
    Source_Name => "__po_hi_c_driver_drvmgr_grspw_init";
    Source_Text => ("grspw_api.c", "spwrouter_custom_config.c",
    "po_hi_driver_drvmgr_common.c", "grspw_pkt_lib.c",
    "po_hi_driver_rtems_drvmgr_spacewire.c");
  end spg_grspw_packet_init_rasta;

  thread grspw_packet_poller
  end grspw_packet_poller;

  thread implementation grspw_packet_poller.rasta
  calls
    mycall : {
    pspg : subprogram spg_grspw_packet_poller_rasta;
    };
  properties
    Period => 1 ms;
    Dispatch_Protocol => Background;
  end grspw_packet_poller.rasta;

  abstract grspw_packet_driver
  properties
    Deployment::Version  => "0.1beta";
    Deployment::Help     => "Write your ASN.1 configuration here";
    Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_spacewire);
  end grspw_packet_driver;

  abstract implementation grspw_packet_driver.rasta
  subcomponents
    receiver_rasta_grspw_packet : thread grspw_packet_poller.rasta;
    sender                   : subprogram spg_grspw_packet_sender_rasta;
  end grspw_packet_driver.rasta;

end ocarina_drivers_grspw_packet;
package ocarina_drivers_apbuart_serial
public

  -- This driver works for RTEMS 5 (presumably RTEMS 4.11) based on
  -- drvmgr driver subsystem, using GRSPW Packet driver.
  --
  -- See Chapter 18 of RCC 1.3 manual

   with Deployment;
   with ocarina_buses;
   with ocarina_drivers;

   subprogram spg_serial_poller
   properties
     Source_Language => (C);
     Source_Name => "__po_hi_c_driver_rtems_drvmgr_serial_poller";
     Source_Text => ("po_hi_driver_drvmgr_common.c",
                     "po_hi_driver_rtems_drvmgr_serial.c");
   end spg_serial_poller;

   subprogram spg_serial_sender
   properties
     Source_Language => (C);
     Source_Name => "__po_hi_c_driver_rtems_drvmgr_serial_sender";
     Source_Text => ("po_hi_driver_drvmgr_common.c",
                     "po_hi_driver_rtems_drvmgr_serial.c");
   end spg_serial_sender;

   subprogram spg_serial_init
   properties
     Source_Language => (C);
     Source_Name => "__po_hi_c_driver_rtems_drvmgr_serial_init";
     Source_Text => ("po_hi_driver_drvmgr_common.c",
                     "po_hi_driver_rtems_drvmgr_serial.c");
   end spg_serial_init;

   thread serial_poller
   end serial_poller;

   thread implementation serial_poller.impl
   calls
     mycall : {
      pspg : subprogram spg_serial_poller;
    };
   properties
     Period => 1ms;
     Dispatch_Protocol => Background;
   end serial_poller.impl;

abstract serial_driver
properties
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_serial);
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end serial_driver;

abstract implementation serial_driver.impl
subcomponents
   receiver_apbuart_serial : thread serial_poller.impl;
   sender                : subprogram spg_serial_sender;
end serial_driver.impl;

end ocarina_drivers_apbuart_serial;
package ocarina_drivers_greth
public

with Deployment;
with ocarina_buses;
with ocarina_drivers;

  -- This driver works for RTEMS 5 (presumably RTEMS 4.11) based on
  -- drvmgr driver subsystem, using GRETH driver.
  --
  -- No chapter in RCC 1.3 manual

subprogram spg_greth_poller
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_rtems_drvmgr_ethernet_poller";
     Source_Text => ("po_hi_driver_drvmgr_common.c",
                     "po_hi_driver_rtems_drvmgr_ethernet.c");
end spg_greth_poller;


subprogram spg_greth_sender
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_rtems_drvmgr_ethernet_sender";
     Source_Text => ("po_hi_driver_drvmgr_common.c",
                     "po_hi_driver_rtems_drvmgr_ethernet.c");
end spg_greth_sender;

subprogram spg_greth_init
properties
        Source_Language => (C);
        Source_Name => "__po_hi_c_driver_rtems_drvmgr_ethernet_init";
     Source_Text => ("po_hi_driver_drvmgr_common.c",
                     "po_hi_driver_rtems_drvmgr_ethernet.c");
end spg_greth_init;

thread thr_poller
end thr_poller;


thread implementation thr_poller.i
calls
        mycall : {
          pspg : subprogram spg_greth_poller;
        };
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end thr_poller.i;

abstract eth_driver
properties
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_ip);
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end eth_driver;

abstract implementation eth_driver.leon
subcomponents
   sender                : subprogram spg_greth_sender;
end eth_driver.leon;

abstract implementation eth_driver.leon_sender
subcomponents
   sender                : subprogram spg_greth_sender;
end eth_driver.leon_sender;

end ocarina_drivers_greth;



-- mapping TASTE : AADL
-- Node : System
-- Processor : Processor
-- Process : Function
-- Bus : Bus
-- Device : Device
-- Driver : Driver
property set TASTE_DV_Properties is
--  MyBoolean: aadlboolean applies to (System, Processor, Process);
    CoverageEnabled: aadlboolean applies to (Process);
    Comment: aadlstring applies to (Device, Bus);
--  MyInt: aadlinteger applies to (System);
--  MyReal: aadlreal applies to (Bus);
--  MyEnum: enumeration  (val1, val2, val3, val4) applies to (Device);
end TASTE_DV_Properties;



-- mapping TASTE : AADL
-- Container : Package
-- Function : System
-- Interface : Subprogram
property set TASTE_IV_Properties is
--  MyBoolean: aadlboolean applies to (System, Package);
--  MyString: aadlstring applies to (System, Subprogram);
    Version: aadlstring applies to (System);
--  MyInt: aadlinteger applies to (System);
--  MyReal: aadlreal applies to (System);
--  MyEnum: enumeration  (val1, val2, val3, val4) applies to (System);
    MSCFiles : aadlstring applies to (Subprogram);
    is_Component_Type : aadlboolean applies to (System);
    is_instance_of    : aadlstring applies to (System);
--    MSCFiles : list of aadlstring applies to (Subprogram);
end TASTE_IV_Properties;



