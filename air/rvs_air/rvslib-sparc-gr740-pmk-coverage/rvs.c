/* RVS - C Map and Trace Instrumentation library */
/* RVS 3.14 */

/*=============================================================================
* Rapita Systems Ltd. - Rapita Verification Suite (RVS) Source Code License
*
* DOC13027 V1 (2014/01/28)
*
* (c) 2004-2020 Rapita Systems Ltd. All rights reserved
* -----------------------------------------------------------------------------
*
* Subject to the terms and conditions of the RVS License Agreement, Rapita
* Systems Ltd. grants the Licensee a non-exclusive, non-transferable license to
* use the source code contained in this file (the "Licensed Software").
*
* The Licensee may use the Licensed Software for its own use, and may
* translate or modify it or incorporate it into other software. The Licensee
* may not, however, alter or remove the copyright notice or the text of the
* source code license.
*
* The Licensee may not, however, transfer or sublicense the Licensed Software
* to any third party, in whole or in part, in any form, whether modified or
* unmodified without the prior written consent of Rapita Systems Ltd.
*
* The original and any copies of the Licensed Software, made by the Licensee,
* including translations, compilations, partial copies, modifications,
* and updates, are the property of Rapita Systems Ltd.
*
* The Licensee recognizes that Rapita Systems Ltd. regards the Licensed
* Software as its proprietary information and as confidential trade secrets.
*
* The Licensee agrees not to provide or to otherwise make available in any
* form the Licensed Software, or any portion thereof, to any person other
* than employees of the Licensee without the prior written consent of
* Rapita Systems Ltd.
*
* The Licensee further agrees to treat the Licensed Programs with at least
* the same degree of care with which the Licensee treats its own confidential
* information and in no event with less care than is reasonably required to
* protect the confidentiality of the Licensed Software.
*
* -----------------------------------------------------------------------------
*
* Registered in the UK, number 5011090.
* Registered address:
*   Atlas House, Link Business Park
*   Osbaldwick Link Road
*   York
*   YO10 3JB
*   UK
* Phone: +44 (0) 1904 413 945
*
* email: support@rapitasystems.com
* http://www.rapitasystems.com/
*
*=============================================================================
*/

// #include <pmk.h>
// #include <printk.h>
#include "rvs.h"
#include "rvs_ipoint.h"

// #include <stdlib.h>
// #include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

/*************************************************************
 * The file rvs_map.h is generated by a call to 'rvdutils --create-map'.
 * It contains code (data declaration, constants, etc.) specific to one
 * analysis (i.e. on RVD) and must be regenerated every time the RVD
 * is re-created.
 *************************************************************/
#include "rvs_map.h"

#ifdef RVS_SEGMENTED
   #define RAPICOVER_DATA(idx) rvs_map_rapicover_data(idx)
   #define ALL_DATA_8(idx) rvs_get_all_data8(idx)
#else
   #define RAPICOVER_DATA(idx) (rvs_rapicover_data + (idx))
   #ifdef RVS_NEW_MAP
      #define ALL_DATA_8(idx) rvs_get_all_data8(idx)
   #else
      #define ALL_DATA_8(idx) (rvs_all_data8 + (idx))
   #endif
#endif

/*=----------------------------------------------------------------------=*\
  Use :Initialises RVS. This is an optional call typically inserted into the
      :code under test as early as possible. If required, call this before
      :ipoints are written out
      :
      :Typical uses of this are:
      : * Set up GPIO pins
      : * Initialise a dynamic-map block
      : * Open an output stream
      :
      :Be aware that if this is required then ipoints written out before
      :RVS_Init() is called may be lost or corrupt
      :
      :Typically RVS_Init() is called once
      :
\*=----------------------------------------------------------------------=*/
void RVS_Init(void)
{
   // FILE *file_ptr;

   /* Initialize the coverage data */
   rvs_map_init();
   /* Clear the output file */
   // file_ptr = fopen("rvs_map.bin", "wb");
   // fclose(file_ptr);

}

// static void insert_int(int values, FILE *file_ptr, int size)
// {
//    int nb_bytes = size / 8;
//    int i;
//    for(i = 0; i < nb_bytes; ++i)
//    {
//       unsigned char char_value = (unsigned char)(values % 256);
//       putc(char_value, file_ptr);
//       values -= char_value;
//       values /= 256;
//    }
// }

// static void insert_int8(t_rvs_uint8 *values, FILE *file_ptr)
// {
//    /* Due to segmented mode that can have an actual
//     * size smaller than rvs_header->total_max_size8
//     * We need to check that the values pointer isn't null */
//    if(values != 0)
//    {
// 	   insert_int(*values, file_ptr, 8);
//    }
// }

/*=----------------------------------------------------------------------=*\
  Use :Outputs RVS data. This is an optional call typically inserted into the
      :code under test as late as possible. If required, call this after
      :ipoints are written out
      :
      :Typical uses of this are:
      : * Upload a map
      : * Flush a memory buffer
      : * Disable subsequent ipoints
      :
      :Be aware that if this is required then ipoints written out after
      :RVS_Output() is called may be lost or corrupt
      :
      :Some integrations may call RVS_Output() multiple times (the test
      :framework calls this via RVS_End_Test() once per test). Other integrations
      :may call this once only once a run is complete
      :
\*=----------------------------------------------------------------------=*/
void RVS_Output(void)
{

   unsigned int i;
   volatile unsigned int z = 0;
   // FILE *file_ptr;

   /* ----- Output the map file ----- */
   /* Check for buffer overflow */
   if (rvs_header->dynamic_overflow)
   {
      /* Trigger a div0 exception to flag the error */
      i = 1;
      i = i / z;
   }

   /* The following output is not required if, for example, the mcdc_data array
    * Is extracted using a debugger (memory dump) */

   /* Output all data */
   // file_ptr = fopen("rvs_map.bin", "ab");
   // printk("RVS_TEST_DUMP_INIT\n");
   for(i = 0; i < rvs_header->total_max_size8; i++)
   {
      /* Replace the following line by your own implementation (if required, see comment above) */
      // insert_int8(ALL_DATA_8(i), file_ptr);
      // printk("%d 0\n", (int) rvs_all_data8[i]);
   }
   // printk("RVS_TEST_DUMP_END\n");
   // fclose(file_ptr);

   /* Clear all data after output */
   rvs_map_reset();

}

/*=----------------------------------------------------------------------=*\
  Use :Set the build id for the instrumented source code.
      :The mechanism here varies based on whether a map or a trace is used
      :but it is typically not required to alter this from the default if
      :using a standard map or trace implementation
      :
      :The build id affects the entire code and should be set consistently
      :across map uploads. Note resetting the map will reset the build ID
      :
\*=----------------------------------------------------------------------=*/
void RVS_Build_Id(const char *build_id)
{

   rvs_header->build_id_idx = rvs_map_alloc_dynamic_string(build_id);

}

/*=----------------------------------------------------------------------=*\
  Use :Marks a test as 'begun'. The mechanism here varies based on whether a
      :map or a trace is used but it is typically not required to alter this
      :from the default if using a standard map or trace implementation
      :
      :This can be called manually if performing system testing to identify
      :different sections of the run. It is called automatically by the
      :RVS test framework
      :
\*=----------------------------------------------------------------------=*/
void RVS_Begin_Test(t_rvs_test_id test_id, const char *test_description)
{

   /* ----------
      Coverage (map)
   */
   /* Clear all data before update */
   rvs_map_reset();

   rvs_rapicover_header->test_id.T[0] = test_id & 0xFFFFFFFF;
   rvs_rapicover_header->test_id.T[1] = test_id >> 32;
   rvs_rapicover_header->test_name_idx = rvs_map_alloc_dynamic_string(test_description);

}

/*=----------------------------------------------------------------------=*\
  Use :Marks a test as 'complete'. The mechanism here varies based on whether a
      :map or a trace is used but it is typically not required to alter this
      :from the default if using a standard map or trace implementation
      :
      :This can be called manually if performing system testing to identify
      :different sections of the run. It is called automatically by the
      :RVS test framework
      :
\*=----------------------------------------------------------------------=*/
void RVS_End_Test(void)
{
   RVS_Output();
   // air_syscall_shutdown_module();
}

/*=----------------------------------------------------------------------=*\
  Use :Marks the transition between an existing test and a new test
      :This call assumes a test is currently active, outputs it and starts a
      :new test
      :It is provided as a convenience function wrapping End_Test() and Begin_Test()
\*=----------------------------------------------------------------------=*/
void RVS_Next_Test(t_rvs_test_id test_id, const char *test_description)
{
   RVS_End_Test();
   RVS_Begin_Test(test_id, test_description);
}

/*=----------------------------------------------------------------------=*\
  Use :Computes the CRC of the map data and stores the result in the map header
      :This is the same calculation used by GNAT.CRC32, PKZip and Ethernet
      :
      :This may optionally be called before RVS_Output() for greater reliability
      :on upload. By default the CRC is 0 and ignored
      :
      :Alter RVS_Output() to call this directly as required
      :
\*=----------------------------------------------------------------------=*/
void RVS_CRC32(void)
{
   /* Compute CRC32 (polynomial 0x4C11DB7) without using a lookup table */
   /* This is the same calculation used by GNAT.CRC32, PKZip and Ethernet */
   t_rvs_uint32 tmp = 0xFFFFFFFF;
   t_rvs_uint32 i, j;
   for (i=12; i<rvs_header->total_used_size8; i++)
   {
      tmp ^= *ALL_DATA_8(i);
      for (j=0; j<8; j++)
      {
         tmp = (tmp >> 1) ^ ((tmp & 1) ? 0xEDB88320 : 0);
      }
   }
   rvs_header->crc32 = tmp ^ 0xFFFFFFFF; /* set CRC */
   rvs_header->valid |= 0x1; /* set CRC valid bit */
}

/*=----------------------------------------------------------------------=*\
  Use :MCDC condition marker
\*=----------------------------------------------------------------------=*/
t_rvs_mcdc_bool RVS_CM(t_rvs_uint32_ptr k, t_rvs_mcdc_cond_idx idx, t_rvs_mcdc_bool b)
{
   *k |= ((t_rvs_uint32)(b ? 1 : 0)) << idx;
   return b;
}

/*=----------------------------------------------------------------------=*\
  Use :MCDC decision marker
\*=----------------------------------------------------------------------=*/
t_rvs_mcdc_bool RVS_DM(t_rvs_ipoint_id id, t_rvs_uint32_ptr k, t_rvs_mcdc_bool b)
{
   *k |= (b ? 2 : 1);
   *RAPICOVER_DATA(id+((*k)>>3)) |= (1<<((*k) & 0x7));
   *k = 0;
   return b;
}

/*=----------------------------------------------------------------------=*\
  Use :MCDC large decision marker
\*=----------------------------------------------------------------------=*/
t_rvs_mcdc_bool RVS_DML(t_rvs_ipoint_id id, t_rvs_uint32_ptr k, t_rvs_mcdc_bool b)
{
   *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) =
      3 | (rvs_map_append32(((*k)|(b ? 2 : 1)), *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) >> 2) << 2);
   *k = 0;
   return b;
}

/*=----------------------------------------------------------------------=*\
  Use :MCDC condition and decision for up to 6 conditions
\*=----------------------------------------------------------------------=*/
t_rvs_mcdc_bool RVS_CM8(t_rvs_key8 *k, t_rvs_mcdc_cond_idx idx, t_rvs_mcdc_bool b)
{
   *k |= ((t_rvs_key8)(b ? 1 : 0)) << idx;
   return b;
}
t_rvs_mcdc_bool RVS_DM8(t_rvs_ipoint_id id, t_rvs_key8 *k, t_rvs_mcdc_bool b)
{
   *k |= (b ? 2 : 1);
   *RAPICOVER_DATA(id + ((*k) >> 3)) |= (1 << ((*k) & 0x7));
   *k = 0;
   return b;
}
t_rvs_mcdc_bool RVS_DML8(t_rvs_ipoint_id id, t_rvs_key8 *k, t_rvs_mcdc_bool b)
{
  *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) =
     3 | (rvs_map_append32(((*k) | (b ? 2 : 1)), *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) >> 2) << 2);
  *k = 0;
  return b;
}

/*=----------------------------------------------------------------------=*\
  Use :MCDC condition and decision for up to 14 conditions
\*=----------------------------------------------------------------------=*/
t_rvs_mcdc_bool RVS_CM16(t_rvs_key16 *k, t_rvs_mcdc_cond_idx idx, t_rvs_mcdc_bool b)
{
   *k |= ((t_rvs_key16)(b ? 1 : 0)) << idx;
   return b;
}
t_rvs_mcdc_bool RVS_DML16(t_rvs_ipoint_id id, t_rvs_key16 *k, t_rvs_mcdc_bool b)
{
   *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) =
      3 | (rvs_map_append32(((*k) | (b ? 2 : 1)), *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) >> 2) << 2);
   *k = 0;
   return b;
}

/*=----------------------------------------------------------------------=*\
  Use :MCDC condition and decision for up to 30 conditions
\*=----------------------------------------------------------------------=*/
t_rvs_mcdc_bool RVS_CM32(t_rvs_key32 *k, t_rvs_mcdc_cond_idx idx, t_rvs_mcdc_bool b)
{
   *k |= ((t_rvs_key32)(b ? 1 : 0)) << idx;
   return b;
}
t_rvs_mcdc_bool RVS_DML32(t_rvs_ipoint_id id, t_rvs_key32 *k, t_rvs_mcdc_bool b)
{
   *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) =
      3 | (rvs_map_append32(((*k) | (b ? 2 : 1)), *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) >> 2) << 2);
   *k = 0;
   return b;
}

/*=----------------------------------------------------------------------=*\
  Use :MCDC condition and decision for up to 62 conditions
\*=----------------------------------------------------------------------=*/
t_rvs_mcdc_bool RVS_CM64(t_rvs_key64 *k, t_rvs_mcdc_cond_idx idx, t_rvs_mcdc_bool b)
{
   *k |= ((t_rvs_key64)(b ? 1 : 0)) << idx;
   return b;
}
t_rvs_mcdc_bool RVS_DML64(t_rvs_ipoint_id id, t_rvs_key64 *k, t_rvs_mcdc_bool b)
{
   *k |= (b ? 2 : 1);
   *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) =
      3 | (rvs_map_appendX((void *)k, *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) >> 2, 2) << 2);
   *k = 0;
   return b;
}

/*=----------------------------------------------------------------------=*/
 /* Use :MCDC condition and decision for up to 126 conditions */
 /*=----------------------------------------------------------------------=*/
 t_rvs_mcdc_bool RVS_CM128 (t_rvs_key128 *k, t_rvs_mcdc_cond_idx idx, t_rvs_mcdc_bool b)
 {
    k->d[idx >> 5] |= ((t_rvs_key64)(b ? 1 : 0)) << (idx & 0x1F);
    return b;
 }

 t_rvs_mcdc_bool RVS_DML128 (t_rvs_ipoint_id id, t_rvs_key128 *k, t_rvs_mcdc_bool b)
 {
    t_rvs_uint8 i;
    k->d[0] |= b ? 2 : 1;
    *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) =
       3 | (rvs_map_appendX((void *)k, *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) >> 2, 4) << 2);
    for (i = 0; i < 4; i++)
    {
       k->d[i] = 0;
    }
    return b;
 }
/*=----------------------------------------------------------------------=*/
 /* Use :MCDC condition and decision for up to 254 conditions */
 /*=----------------------------------------------------------------------=*/
 t_rvs_mcdc_bool RVS_CM256 (t_rvs_key256 *k, t_rvs_mcdc_cond_idx idx, t_rvs_mcdc_bool b)
 {
    k->d[idx >> 5] |= ((t_rvs_key64)(b ? 1 : 0)) << (idx & 0x1F);
    return b;
 }

 t_rvs_mcdc_bool RVS_DML256 (t_rvs_ipoint_id id, t_rvs_key256 *k, t_rvs_mcdc_bool b)
 {
    t_rvs_uint8 i;
    k->d[0] |= b ? 2 : 1;
    *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) =
       3 | (rvs_map_appendX((void *)k, *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) >> 2, 8) << 2);
    for (i = 0; i < 8; i++)
    {
       k->d[i] = 0;
    }
    return b;
 }
/*=----------------------------------------------------------------------=*/
 /* Use :MCDC condition and decision for up to 510 conditions */
 /*=----------------------------------------------------------------------=*/
 t_rvs_mcdc_bool RVS_CM512 (t_rvs_key512 *k, t_rvs_mcdc_cond_idx idx, t_rvs_mcdc_bool b)
 {
    k->d[idx >> 5] |= ((t_rvs_key64)(b ? 1 : 0)) << (idx & 0x1F);
    return b;
 }

 t_rvs_mcdc_bool RVS_DML512 (t_rvs_ipoint_id id, t_rvs_key512 *k, t_rvs_mcdc_bool b)
 {
    t_rvs_uint8 i;
    k->d[0] |= b ? 2 : 1;
    *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) =
       3 | (rvs_map_appendX((void *)k, *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) >> 2, 16) << 2);
    for (i = 0; i < 16; i++)
    {
       k->d[i] = 0;
    }
    return b;
 }
/*=----------------------------------------------------------------------=*/
 /* Use :MCDC condition and decision for up to 1022 conditions */
 /*=----------------------------------------------------------------------=*/
 t_rvs_mcdc_bool RVS_CM1024 (t_rvs_key1024 *k, t_rvs_mcdc_cond_idx idx, t_rvs_mcdc_bool b)
 {
    k->d[idx >> 5] |= ((t_rvs_key64)(b ? 1 : 0)) << (idx & 0x1F);
    return b;
 }

 t_rvs_mcdc_bool RVS_DML1024 (t_rvs_ipoint_id id, t_rvs_key1024 *k, t_rvs_mcdc_bool b)
 {
    t_rvs_uint8 i;
    k->d[0] |= b ? 2 : 1;
    *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) =
       3 | (rvs_map_appendX((void *)k, *((t_rvs_uint32_ptr)(RAPICOVER_DATA(id))) >> 2, 32) << 2);
    for (i = 0; i < 32; i++)
    {
       k->d[i] = 0;
    }
    return b;
 }

#ifdef __cplusplus
} /* extern "C" */
#endif
