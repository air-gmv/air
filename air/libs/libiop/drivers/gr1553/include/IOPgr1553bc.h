/**
 *  @file 
 *  @brief Header for GR1553 BC mode
 *
 *  COPYRIGHT (c) 2011.
 *  GMV-SKYSOFT
 *	
 *  Modifications: 
 *    - Back port to RTEMS 4.8 (no drvmgr)
 *    - Removed Interrupts
 *
 *  @author Clï¿½udio Silva
 *	
 */
/*  GR1553B BC driver
 *
 *  COPYRIGHT (c) 2010.
 *  Aeroflex Gaisler.
 *
 *  The license and distribution terms for this file may be
 *  found in the file LICENSE in this distribution or at
 *  http://www.rtems.com/license/LICENSE.
 *
 *  2010-03-15, Daniel Hellstrom <daniel@gaisler.com>
 *    Created
 *
 *
 * OVERVIEW
 * ========
 * This driver controls the BC device, located at an on-chip AMBA or an
 * AMBA-over-PCI bus. The driver operates the BC device and provides you
 * with interrupt services and core control. The driver start execution of
 * a synchronuos and/or an asynchronous BC descriptor List. The list contains
 * a descriptor table and a software description to make some operations
 * possible, for example translate descriptor-address into descriptor-number.
 *
 * BC descriptors are generated by the list API, available in gr1553bc_list.h.
 *
 * See gr1553bc_list.h for more information.
 */

#ifndef __GR1553BC_H__
#define __GR1553BC_H__

#include <stdint.h>
#include <IOPgr1553b.h>
#include <IOPlibio.h>
#include <iop.h>
#include <rtems/score/chain.h>
#include <IOPmilstd_config.h>

/* A BC descriptor accessed as is */
struct gr1553bc_bd_raw {
	volatile uint32_t words[4];
};

/* A BC descriptor accessed as a transfer descriptor */
struct gr1553bc_bd_tr {
	volatile uint32_t settings[2];
	volatile uint32_t dptr;
	volatile uint32_t status;
};

/* A BC descriptor accessed as a conditional descriptor */
struct gr1553bc_bd_cond {
	volatile uint32_t cond;
	volatile uint32_t bdptr;
	volatile uint32_t padding[2];
};

/* A BC descriptor accessed any way */
union gr1553bc_bd {
	struct gr1553bc_bd_raw raw;
	struct gr1553bc_bd_tr tr;
	struct gr1553bc_bd_cond cond;

};

typedef struct {
	iop_chain_node node;				/**< RTEMS Chain Node */
	unsigned char subaddr;			/**< RT subaddress */
	unsigned char wcmc;				/**< Word Count / Mode Code */
	void *cmd_ptr;					/**< pointer to command */
} write_cmd_shortcut_t;

#define GR1553B_MODE_BC 0x0		/**< Bus Controler Mode*/
#define GR1553B_MODE_RT 0x1		/**< Remote terminal Mode*/
#define GR1553B_MODE_BM 0x2		/**< Bus Monitor Mode*/

/* Alignment of a descriptor */
#define GR1553BC_BD_ALIGN 16

/* End of list marker */
#define GR1553BC_TR_EOL 0x80ffffff

#define GR1553BC_BD_TYPE	0x80000000

/* Condition descriptor bits */
#define GR1553BC_UNCOND_JMP	0x820000ff
#define GR1553BC_UNCOND_IRQ	0x860000ff
#define GR1553BC_UNCOND_NOJMP	0x82000000

/* Transfer descriptor bits */
#define GR1553BC_TR_DUMMY_0	0x00000000
#define GR1553BC_TR_DUMMY_1	0x80000000

#define GR1553BC_TR_TIME	0x0000ffff

#define GR1553BC_TR_EXTTRIG	0x40000000

#define GR1553BC_STATUS_ACESSED 0x80000000

void gr1553bc_device_init(grb_priv *priv);
void gr1553bc_close(grb_priv *priv);
void gr1553bc_stop(grb_priv *priv, int options);
void gr1553bc_device_uninit(grb_priv *priv);

void gr1553bc_init_list();
void gr1553bc_pause_list();
void gr1553bc_continue_list();

void gr1553bc_start_async();
void gr1553bc_start_sync();

rtems_status_code gr1553bc_add_async_data(uint8_t *data, milstd_header_t *hdr, uint32_t size);
rtems_status_code gr1553bc_erase_async_data();

rtems_status_code grbc_merge_data_with_command(uint8_t *data, milstd_header_t *hdr, uint32_t size);
rtems_status_code grbc_process_completed_commands(libio_rw_args_t *rw_args);

unsigned long get_virtual_addr(unsigned long p_addr);

#endif
